<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_3.xsd">
  <name>CCG2</name>
  <version>1.0</version>
  <description>CCG2 family is the 2nd generation, USB Type-C controller targeted for Electronically Marked Cable Assembly.</description>
  <cpu>
    <name>CM0</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>0x20</size>
  <access>read-write</access>
  <protection>n</protection>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register
The (PA_SEL_TYPE, PA_SEL_DIV) field pair allows a divider to be phase
aligned with another divider. E.g., consider a 48 MHz "clk_hf", and a
need for a 12 MHz divided clock A and a 8 MHz divided clock B. Clock 
A uses 8.0 integer divider 0 and is created by aligning it to "clk_hf"
((PA_SEL_TYPE, PA_SEL_DIV) is (3, 63)) and DIV_8_CTL0.INT8_DIV is "4-1".
Clock  B uses 8.0 integer divider 1 and is created by aligning it to clock
A ((PA_SEL_TYPE, PA_SEL_DIV) is (0, 0)) and DIV_8_CTL1.INT8_DIV is "6-1".
This guarantees that clock B is phase aligned with clock B: as the smallest
common multiple of the two clock periods is 12 "clk_hf" cycles, the clocks
A and B will be aligned every 12 "clk_hf" cycles. Note: clock B is phase
aligned to clock A, but still uses "clk_hf" as a reference clock for its
divider value.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE)
is performed.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) pecifies the divider to which phase alignment
is performed for the clock enable command. Any enabled divider can be
used as reference. This allows all dividers to be aligned with each other,
even when they are enabled at different times.
If PA_SEL_DIV is "63" and "PA_SEL_TYPE" is "3", "clk_hf" is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is
performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exlusive with ENABLE). SW sets
this field to '1' and HW sets this field to '0'.
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN
field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically,
SW sets this field to '1' to enable a divider and HW sets this field to
'0' to indicate that divider enabling has completed. When a divider is
enabled, its integer and fractional (if present) counters are initialized
to "0". If a divider is to be re-enabled using different integer and fractional
divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled.
The enabled divider may be phase aligned to either "clk_hf" (typical usage)
or to ANY enabled divider.
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
The HW sets the ENABLE field to '0' when the enabling is performed and
the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling
is performed. Note that enabling with phase alignment to a low frequency
divider takes time. E.g. To align to a divider that generates a clock
of "clk_hf"/n (with n being the integer divider value INT_DIV+1), up to
n cycles may be required to perform alignment. Phase alignment to "clk_hf"
takes affect immediately. SW can set this field to '0' during phase alignment
to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL0</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL1</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x104</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL2</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x108</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL3</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x10C</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL4</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x110</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL5</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x114</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL6</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x118</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL7</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x11C</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL8</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x120</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL9</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x124</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCLK_CTL10</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x128</addressOffset>
          <resetValue>0x000000C3</resetValue>
          <resetMask>0x000000C3</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
If SEL_DIV is "63" and "SEL_TYPE" is "3" (default/reset value), no divider
is specified and no clock control signal(s) are generated.
When transitioning a clock between two out of phase dividers, spurious
clock control signals may be generated for one �clk_hf� cycle during this
transition. These clock control signals may cause a single clock period
that is smaller than any of the two divider periods. To prevent these
spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV
is "63" and "SEL_TYPE" is "3") for a transition time that is larger than
the smaller of the two divider periods.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_8_CTL0</name>
          <description>Divider control register (for 8.0 divider)
Smallest of the divider types.</description>
          <addressOffset>0x200</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the
range [1, 256]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 256].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is resticited to even numbers in the range [2, 256]. The
generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_8_CTL1</name>
          <description>Divider control register (for 8.0 divider)
Smallest of the divider types.</description>
          <addressOffset>0x204</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the
range [1, 256]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 256].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is resticited to even numbers in the range [2, 256]. The
generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_8_CTL2</name>
          <description>Divider control register (for 8.0 divider)
Smallest of the divider types.</description>
          <addressOffset>0x208</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the
range [1, 256]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 256].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is resticited to even numbers in the range [2, 256]. The
generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_8_CTL3</name>
          <description>Divider control register (for 8.0 divider)
Smallest of the divider types.</description>
          <addressOffset>0x20C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the
range [1, 256]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 256].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is resticited to even numbers in the range [2, 256]. The
generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_16_CTL0</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the
range [1, 65,536]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 65,536].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is restricted to even numbers in the range [2, 65,536].
The generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_16_CTL1</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x304</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the
range [1, 65,536]. Note: this type of divider does NOT allow for a fractional
division.
For the generation of a divided clock, the integer division range is restricted
to [2, 65,536].
For the generation of a 50/50% duty cycle digital divided clock, the integer
division range is restricted to even numbers in the range [2, 65,536].
The generation of a 50/50 % duty cycle analog divided clock has no restrictions.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_16_5_CTL0</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions
in the range [0, 31/32]. Note that fractional division results in clock
jitter as some clock periods may be 1 "clk_hf" cycle longer than other
clock periods.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the
range [1, 65,536]. Note: combined with fractional division, this divider
type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
For the generation of a divided clock, the division range is restricted
to [2, 65,536 31/32].
For the generation of a 50/50% duty cycle divided clock, the  division
range is restricted to [2, 65,536].
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_16_5_CTL1</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x404</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command.
HW sets this field to '0' as a result on a DISABLE command.
Note that this field is retained. As a result, the divider does NOT have
to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions
in the range [0, 31/32]. Note that fractional division results in clock
jitter as some clock periods may be 1 "clk_hf" cycle longer than other
clock periods.
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the
range [1, 65,536]. Note: combined with fractional division, this divider
type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
For the generation of a divided clock, the division range is restricted
to [2, 65,536 31/32].
For the generation of a 50/50% duty cycle divided clock, the  division
range is restricted to [2, 65,536].
Note that this field is retained. However, the counter that is used to
implement the division is not and will be initialized by HW to "0" when
transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>HSIOM_PRT0</name>
          <addressOffset>0</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS0_ext_clk</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_uart_cts</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CPUSS0_swd_data</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_select0</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_i2c_sda</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SCB0_uart_rts</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CPUSS0_swd_clk</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_miso</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_i2c_scl</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>HSIOM_PRT1</name>
          <addressOffset>256</addressOffset>
          <register>
            <name>PORT_SEL1</name>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM0_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM0_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_uart_tx</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM0_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USBPD0_tx_data_en</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_spi_clk</name>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_i2c_scl</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM1_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM1_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_uart_cts</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM1_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CPUSS0_swd_data</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_spi_mosi</name>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO2_SEL</name>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM2_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM2_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM2_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CPUSS0_swd_clk</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO3_SEL</name>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS0_ext_clk</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_uart_rx</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_select0</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_spi_miso</name>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_i2c_sda</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO4_SEL</name>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO5_SEL</name>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM3_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM3_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_uart_rts</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM3_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USBPD0_cmp_out</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_miso</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB1_spi_select0</name>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO6_SEL</name>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO7_SEL</name>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM4_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM4_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_uart_tx</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM4_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USBPD0_tx_data</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_mosi</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_i2c_sda</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>HSIOM_PRT2</name>
          <addressOffset>512</addressOffset>
          <register>
            <name>PORT_SEL2</name>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TCPWM5_line</name>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM5_tr_compare_match</name>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_uart_rx</name>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM5_tr_overflow</name>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>USBPD0_cmp_out</name>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_spi_clk</name>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SCB0_i2c_scl</name>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO2_SEL</name>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO3_SEL</name>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <value>0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSSLT</name>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WDT</name>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>SPCIF</name>
        <value>8</value>
      </interrupt>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control
Controls the device power mode options and allows observation of current
state.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x008F003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read
in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulator is ready to enter DEEPSLEEP
mode.
0: If DEEPSLEEP mode is requested, device will enter SLEEP mode.  When
low power regulators are ready, device will automatically enter the originally
requested mode.
1: Normal operation.  DEEPSLEEP works as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVER_TEMP_EN</name>
              <description>Enables the die over temperature sensor.  Must be enabled when using the
TEMP_HIGH interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP_THRESH</name>
              <description>Over-temperature threshold.
0: TEMP_HIGH condition occurs between 120C and 125C.
1: TEMP_HIGH condition occurs between 60C and 75C (used for testing).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare AHB readback bits that are hooked to PWR_PWRSYS_TRIM1.SPARE_TRIM[1:0]
through spare logic equivalent to bitwise inversion.  Engineering only.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Always write 0 except as noted below.
PSoC4-S0 and Streetfighter CapSense products may set this bit if Vccd
is provided externally (on Vccd pin).  Setting this bit turns off the
active regulator and will lead to system reset (BOD) unless both Vddd
and Vccd pins are supplied externally.  This register bit only resets
for XRES, POR, or a detected BOD.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register</description>
          <addressOffset>0x4</addressOffset>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay to wait for references to settle on wakeup from deepsleep.  BOD
is ignored and system does not resume until this delay expires. Note that
the same delay on POR is hard-coded.  The default assumes the output of
the predivider is 48MHz + 3%.  Firmware may scale this setting according
to the fastest actual clock frequency that can occur when waking from
DEEPSLEEP.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_ADFT_SELECT</name>
          <description>Power ADFT Mode Selection Register
Controls System Resources ADFT mode settings and observability.   Writes
to this register are ignored and settings in this register have no effect
unless the part is in a XRES key selected DfT mode.  Entire register is
engineering only.  Note that PWR_DDFT_XRES can be used to enter an XRES
key if XRES key sequence is not desired.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE000031F</resetMask>
          <fields>
            <field>
              <name>SRSS_SEL</name>
              <description>Selects the current or voltage source from SRSS-Lite that needs to be
observed.  Currents are only available through amuxbusa.  Voltages are
available though both amuxbusa and amuxbusb (Kelvin connections).</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IREF0</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF1</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF2</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF3</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF4</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF5</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF6</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF7</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF8</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF9</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF10</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF11</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF12</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF13</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF14</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF15</name>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF16</name>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF17</name>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF18</name>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF19</name>
                  <value>19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_MAIN</name>
                  <value>20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_LOCAL</name>
                  <value>21</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_SPARE1</name>
                  <value>22</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_IMO_REG</name>
                  <value>23</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VCCD</name>
                  <value>24</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBG_1P25</name>
                  <value>25</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_1P2</name>
                  <value>26</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSREF_0P74</name>
                  <value>27</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSSD</name>
                  <value>28</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREG_1P55</name>
                  <value>29</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSSQ</name>
                  <value>30</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_ALL</name>
                  <value>31</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRSS_AMUXA</name>
              <description>Connect amuxbusa to selected ADFT signal.
0: do not connect
1: connect</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRSS_AMUXB</name>
              <description>Connect amuxbusb to selected ADFT signal.
0: do not connect
1: connect</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEED_EN</name>
              <description>When set enables bleeder cells on various switched power nets to accelerate
discharge during low power mode testing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POR_TRIGGER</name>
              <description>Setting this bit will trigger a rst_por_hv_n reset from the s8srsslta.
 The system will go through POR reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRSS_EN</name>
              <description>Enables/disables the system resources ADFT observability.  Disable this
bit before changing the ADFT selection.  This prevents glitches and transients
from affecting the references.  There is no internal hardware break-before-make.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DDFT_SELECT</name>
          <description>Power DDFT Mode Selection Register
Selects the signal sources output to the DDFT outputs of the power subsystem.
Entire register is engineering only.</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DDFT0_SEL</name>
              <description>Select signal for power DDFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_EN</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_EN</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REF_EN</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REG_EN</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_EN</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OVER_TEMP_EN</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDREQ_N</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_BUF_EN</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ATPG_OBSERVE</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDFT1_SEL</name>
              <description>Select signal for power DDFT output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_VALID</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REG_VALID</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_OUT</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_TEMP_HIGH</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_OUT</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_POWER_UP</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE_DELAYED</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPM_READY</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDACK_N</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DDFT_XRES</name>
          <description>XRES DfT Key observer logic test register
This register is used to test the XRES TestMode key logic.  It allows
a test routine (firmware or ATE driven) to stimulate the key listener
and observe its functionality.  Extreme case must be taken in these tests,
since they will result in actual test mode entry.  For example, shifting
in a scan mode key, will transition the system into scan mode immediately.
 Note that test_scan_mode is not observable in this register for that
reason.</description>
          <addressOffset>0x10</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0001F0F</resetMask>
          <fields>
            <field>
              <name>KEY_IN</name>
              <description>Tied to the XRES DfT key observation shift register input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_CLK</name>
              <description>Tied to the XRES DfT key observation shift register clock.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HARD_KEY_OUT</name>
              <description>Output of the 32-bit hard key shift register</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Set this to 1 to block all test_key_* signals (blocks both logic side
effects and  bits in this register)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_DFT_EN</name>
              <description>Hooked up to test_key_dft_en</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEY_REG_DISABLE</name>
              <description>Hooked up to test_key_reg_disable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEY_SAFE_MODE</name>
              <description>Hooked up to test_key_safe_mode</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEY_POR_CIRCUIT</name>
              <description>Hooked up to test_key_por_circuit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KEY_CLK_EXT</name>
              <description>Hooked up to test_key_clk_ext</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HARD_KEY_OK</name>
              <description>Indicates that the 32-bit shift register has observed the correct key</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SOFT_KEY_OK</name>
              <description>Indicates that the 125-bit key observer has observed the correct key</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_MODE</name>
          <description>Test Mode Control Register
Controls primary test mode.  This is a single bit that can be written
directly from the ATE/Programmer in any protection mode.  It's main function
is to signal to the Boot ROM that normal firmware execution is not to
commence after boot is complete.  Instead the Boot ROM will enter a wait
loop for system commands.</description>
          <addressOffset>0x14</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>0: SWD not active
1: SWD activated (Line Reset &amp; Connect sequence passed)
(Note: this bit replaces TST_CTRL.SWD_CONNECTED and is present in all
M0S8 products except TSG4)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK_ALT_XRES</name>
              <description>Relevant only for parts that have the alternate XRES mechanism of overloading
a GPIO pin temporarily as alternate XRES during test.  When set, this
bit blocks the alternate XRES function, such that the pin can be used
for normal I/O or for ddft/adft observation.  See SAS Part-V and Part-IX
for details. This register bit only resets for XRES, POR, or a detected
BOD.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_KEY_DFT_EN</name>
              <description>This bit is set when a XRES test mode key is shifted in.  It is the value
of the test_key_dft_en signal.  When this bit is set, the BootROM will
not yield execution to the FLASH image (same function as setting TEST_MODE
bit below).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>0: Normal operation mode
1: Test mode (any test mode)
Setting this bit will prevent BootROM from yielding execution to Flash
image.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_DDFT_CTRL</name>
          <description>Digital DFT Control Register
Controls system level DDFT observability muxes and comparators.</description>
          <addressOffset>0x18</addressOffset>
          <resetValue>0x00000F0F</resetValue>
          <resetMask>0x80000F0F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select signal for DDFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SRC0</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC1</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC2</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC3</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC4</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC5</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC6</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC7</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK0</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK1</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR0</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR1</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RES0</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RES1</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_COMP</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSS</name>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select signal for DDFT output #1</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SRC0</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC1</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC2</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC3</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC4</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC5</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC6</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC7</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK0</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK1</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR0</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR1</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RES0</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RES1</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_COMP</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSS</name>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>1: Enables DDFT functionality.  Connects output of DDFT mux to designated
DDFT pin.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_TRIM_CNTR1</name>
          <description>IMO trim down-counter and status (clk_sys)</description>
          <addressOffset>0x1C</addressOffset>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Down-counter clocked on clk_sys. By writing non-zero value to this counter
TRIM_CNTR2.COUNTER clears and counts up. TRIM_CNTR1.COUNTER counts down
until TRIM_CNTR1.COUNTER==0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_DONE</name>
              <description>Status bit indicating that TRIM_CNTR1.COUNTER==0 and TRIM_CNT2.COUNTER
stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_TRIM_CNTR2</name>
          <description>IMO trim up-counter  (ddft)</description>
          <addressOffset>0x20</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Up-counter clocked on Clock DDFT output #1. When TRIM_CNTR1.COUNT_DONE==1
counter stopped and can be read by SW</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_ADFT_CTRL</name>
          <description>ADFT buffer/comparator control register
Controls System Resources ADFT mode settings and observability.  Writes
to this register are ignored and settings in this register have no effect
unless the part is in a XRES key selected DfT mode.  Entire register is
engineering only. Note that PWR_DDFT_XRES can be used to enter an XRES
key if XRES key sequence is not desired.</description>
          <addressOffset>0x24</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80010301</resetMask>
          <fields>
            <field>
              <name>BUF_AUTO_ZERO</name>
              <description>The ADFT buffer/comparator has a common mode dependent offset that can
be greatly reduced by using this register bit.  After settling the input
signal(s), toggle this bit high briefly to sample and componsate for the
offset.  The buffer/comparator output will be unreliable when this bit
is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_MODE</name>
              <description>Selects the operating mode for the ADFT buffer/comparator:
0: Voltage buffer, input is amuxbusa, output is amuxbusb
1: Voltage buffer, input is amuxbusb, output is amuxbusa
2: Comparator, input+ is amuxbusa, input- is amuxbusb
3: Comparator, input+ is amuxbusb, input- is amuxbusa</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_COMP_OUT</name>
              <description>Output of the ADFT comparator, 0 if in analog voltage buffer mode.  This
bit is also observable as a DDFT signal (see PWR_DDFT_SELECT).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_EN</name>
              <description>Enables the functionality of the ADFT buffer/comparator</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register
Configures direction of all clock multiplexers and selectors.  See Section
20.3 in SAS for details on clock network topology.  See PAS for DSI signal
connectivity list.</description>
          <addressOffset>0x28</addressOffset>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects a source for clk_hf and dsi_in[0].  Note that not all products
support all clock sources.  Selecting a clock source that is not supported
will result in undefined behavior.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_DIV</name>
              <description>Selects clk_hf predivider value.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock source for charge pump clock.  This clock is not guaranteed
to be glitch free when changing any of its sources or settings.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>Select clk_sys prescaler value.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration
Internal slow speed R/C oscillator (32kHz) configuration register. Note:
writes to this register are ignored when WDT_DISABLE_KEY is not set to
the magic value defined for it.</description>
          <addressOffset>0x2C</addressOffset>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator.  This bit is hardware set whenever the
WD_DISABLE_KEY is not set to the magic value.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration
Internal high speed R/C oscillator configuration register. Note that this
oscillator comes up active on power up.  The oscillator provides the primary
system clock (HFCLK) on power up until firmware configures differently.
 This oscillator is also used before system start to count out power up
delays.  This is done in fast IMO (FIMO) mode that does not require any
external references and runs at a fixed 12MHz.</description>
          <addressOffset>0x30</addressOffset>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the
IMO.  Don't do this if the system is running off it.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register
Selects which clock signals to bring out to to DFT pins.  Two signals
can be selected to enable comparison of clocks.  Clocks can be divided
down to deal with slower equipment and I/Os.  See TST_DFT_SELECT for details
on bringing these pins out.  Entire register is engineering only.</description>
          <addressOffset>0x34</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select signal for DFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV0</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE0</name>
              <description>Edge sensitivity for in-line divider on output #0 (only relevant when
DIV0>0).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select signal for DFT output #1</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE1</name>
              <description>Edge sensitivity for in-line divider on output #1 (only relevant when
DIV1>0).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_DISABLE_KEY</name>
          <description>Watchdog Disable Key Register
This key can be used to disable the watchdog timer reset generation in
applications that do not require absolute brown-out safety and do not
want to deal with the hassle of feeding the watchdog regularly.  Setting
the key will also enable the CLK_ILO_CONFIG.ENABLE bit to be effective.
 It will not have any other effect, i.e. the WDT timer/interrupt functionality
can still be used.</description>
          <addressOffset>0x38</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Disables WDT reset when equal to 0xACED8865.  The WDT reset functions
normally for any other setting.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_COUNTER</name>
          <description>Watchdog Counter Register
Provides actual counter value for watchdog counter.  Watchdog counter
always counts up, is free-running and is clocked using clk_lf.</description>
          <addressOffset>0x3C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Match Register
Firmware provided match value that is compared against WDT_COUNTER.  The
expectation is that firmware modifies this register after each match as
part of the WDT interrupt service routine.</description>
          <addressOffset>0x40</addressOffset>
          <resetValue>0x00001000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH
an interrupt is generated.  Two unserviced interrupts will lead to a system
reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against
MATCH.  This value provides control over the time-to-reset of the watchdog
(which happens after 3 successive matches).  Note that certain products
may enforce a minimum value for this register through design time configuration.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register
The intent is that this register is cleared for every WDT interrupt under
all circumstances, including when the system is in DeepSleep.</description>
          <addressOffset>0x44</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.
 Clearing this bit also feeds the watch dog.  Missing 2 interrupts in
a row will generate brown-out reset.  Due to internal synchronization,
it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Regulator over-temp interrupt.  This interrupt can occur when a short
circuit exists on the vccd pin or when extreme loads are applied on IO-cells
causing the die to overheat.  Firmware is encourage to shutdown all IO
cells and then go to DeepSleep mode when this interrupt occurs if protection
against such conditions is desired.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register
Can be used to set interrupts for firmware testing. Note that SET functionality
is not available for WDT.</description>
          <addressOffset>0x48</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000002</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Writing 1 to this bit internally sets the overtemp interrupt.  This can
be observed by reading SRSS_INTR.TEMP_HIGH.  This bit always reads back
as zero.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register
Controls whether interrupt is forwarded to CPU.</description>
          <addressOffset>0x4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Clearing this bit will not forward the interrupt to the CPU.  It will
not, however, disable the WDT reset generation on 2 missed interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Masks REG_OVERTEMP interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_ADFT_CONTROL</name>
          <description>SRSS ADFT control register
This register can be used only when in a test mode entered through an
XRES:DFT:* key.  It provides direct control over and visibility of the
SRSS power and reference circuits. Note that act_reg_en is controlled
through PWR_CONTROL.EXT_VCCD.  It is possible to cause behavior that is
normally considered illegal, such as disabling a circuit without regard
for dependencies.  Engineering only. Note that PWR_DDFT_XRES can be used
to enter an XRES key if XRES key sequence is not desired.</description>
          <addressOffset>0x50</addressOffset>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x00000F3F</resetMask>
          <fields>
            <field>
              <name>ACT_REF_EN</name>
              <description>Enables/disables the Active reference.  Set CLK_SELECT.HFCLK_SEL=EXTCLK
before disabling the reference.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_COMP_EN</name>
              <description>Enables/disables the Active power comparator.  Set CLK_SELECT.HFCLK_SEL=EXTCLK
before disabling the comparator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_EN</name>
              <description>Enables/disables the DeepSleep reference</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_EN</name>
              <description>Enables/disables the DeepSleep regulator</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_COMP_EN</name>
              <description>Enables/disables the DeepSleep power comparator</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_MODE</name>
              <description>Mode override for the DeepSleep reference.  0=DEEPSLEEP, 1=ACTIVE.  Clearing
this bit allows characterization of the DeepSleep reference during ACTIVE
mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_VALID</name>
              <description>Indicates Active reference is valid</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACT_REG_VALID</name>
              <description>Indicates Active regulator is regulating</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACT_COMP_OUT</name>
              <description>Indicates Active comparator is valid</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPSLP_COMP_OUT</name>
              <description>Indicates DeepSleep comparator is valid</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register
Indicates the cause for the latest reset(s) that occurred in the system.
 Note that resets due to power up and brown-outs below state retention
voltages in regulated and unregulated domains cannot be distinguished
from eachother.  All bits in this register assert when the corresponding
reset cause occurs and must be cleared by firmware.  These bits are cleared
by hardware only during XRES, POR or after a detected brown-out.</description>
          <addressOffset>0x54</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000019</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes,
but is not limited to, hitting a debug breakpoint while in Privileged
Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can
be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_DFT</name>
          <description>Reset DFT Register
Controls the DFT options for the reset system.   Writes to this register
are ignored and settings in this register have no effect unless DFT is
enabled through a XRES:DFT:* key (see SAS for details).  Note that PWR_DDFT_XRES
can be used to enter an XRES key if XRES key sequence is not desired.</description>
          <addressOffset>0x58</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>DELAY_BLOCK</name>
              <description>Setting this bit will disconnect the output of the reset delay line from
the reset system blocking soft resets from reaching the logic.  Note:
XRES/POR/BOD resets still have other effects, but this bit MUST be cleared
before XRES or any other reset can be applied to the system after doing
the delay line testing.
When DELAY_BLOCK=1, reset DDFT output #0 is connected the input of the
delay line and output #1 is connected to the output of the delay line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_IN</name>
              <description>When DELAY_BLOCK=1, this bit is connected to the input of the reset delay
line.  Both the input and output can be observed through the DDFT network
to measure their timing relationship.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register
Trim bits for Reference System. Entire register is engineering only.</description>
          <addressOffset>0xF00</addressOffset>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>REF_VTRIM</name>
              <description>Trims the bandgap reference voltage output.  Used to trim the VBG to the
voltage where its temperature curvature is minimal.  Bit [5] is unused
within the bandgap block.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register
Trim bits for Reference System. Entire register is engineering only.</description>
          <addressOffset>0xF04</addressOffset>
          <resetValue>0x0000001C</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>REF_ITRIM</name>
              <description>Trims the bandgap reference current output.  Used to trim the IBG to the
voltage where its temperature curvature is minimal.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SELECT</name>
          <description>IMO Frequency Select Register
Selects the operating frequency of the IMO</description>
          <addressOffset>0xF08</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Select operating frequency</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24_MHZ</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>28_MHZ</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_MHZ</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>36_MHZ</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>40_MHZ</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>44_MHZ</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48_MHZ</name>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register
Trims IMO frequency to within datasheet accuracy.  Must be applied</description>
          <addressOffset>0xF0C</addressOffset>
          <resetValue>0x00000080</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time
for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  This field is
hardware updated during USB osclock mode. This field is mapped to the
most significant bits of the IMO trim imo_clk_trim[10:3].  The step size
of 1 LSB on this field is approximately 120 kHz.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register
IMO Trim Bits.   Entire register is engineering only.</description>
          <addressOffset>0xF10</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>FSOFFSET</name>
              <description>Frequency trim bits.  These bits are not trimmed during manufacturing
and kept at 0 under normal operation.  This field is hardware updated
during USB osclock mode. This field is mapped to the least significant
bits of the IMO trim imo_clk_trim[2:0].  The step size of 1 LSB on this
field is approximately 15 kHz.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register
Power System Trim Bits.   Entire register is engineering only.</description>
          <addressOffset>0xF14</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DPSLP_REF_TRIM</name>
              <description>Trims the DeepSleep reference that is used by the DeepSleep regulator
and DeepSleep power comparator.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE_TRIM</name>
              <description>Active-Reference temperature compensation trim (repurposed from spare
bits).
Bits [7:6] - trim the Active-Reference IREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = +80ppm/C
  10: TC = -80ppm/C
  11: TC = -150ppm/C
Bits [5:4] - trim the Active-Reference VREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = -50ppm/C
  10: TC = -80ppm/C
  11: TC = +150ppm/C</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register
IMO Trim Bits.   Entire register is engineering only.</description>
          <addressOffset>0xF18</addressOffset>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>STEPSIZE</name>
              <description>IMO trim stepsize bits.  These bits are determined at manufacturing time
to adjust for process variation.  They are used to tune the stepsize of
the FSOFFSET and OFFSET trims.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCTRIM</name>
              <description>IMO temperature compesation trim.  These bits are determined at manufacturing
time to adjust for temperature dependence. This bits are dependent on
frequency and need to be changed using the Cypress provided frequency
change algorithm.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>PICU0</name>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>PICU1</name>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>PICU2</name>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>GANGEDPICU</name>
        <value>3</value>
      </interrupt>
      <registers>
        <cluster>
          <name>PRT0</name>
          <addressOffset>0</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register
Used to read and write the output data for the IO pads in the port. A
DR register write changes the output data to the written value. A DR register
read reflects the output data (and not the current state of the input
data for the IO pads). Using this DR register, Read-Modify-Write sequences
are safely performed on a port with some IO pads configured as inputs.</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register
Used to read. Writes to this register have no effect. If the drive mode
for the pin is set to high Z Analog, the state will read 0 independent
of the voltage on the pin.</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000103</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold,
logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will
read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register
Configures the output drive and input buffer state for each pin, and the
slew rate and input threshold selection for the whole port. One register
is provided per port.</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFB00003F</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as
I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before
turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage.
Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the
SIO register are used instead (a separate VTRIP_SEL is provided for each
pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>This field is used to improve the hysteresis (to 10% of vddio) of the
selectable trip point input buffer. The voltage reference comes from the
VREFGEN block and is only available when using the VREFGEN block:
'0': &lt;= 2.2 V input signaling Voltage.
'1': > 2.2 V input signaling Voltage.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>Slew control. Only used in the O_Z drive mode (mode 4: strong pull down,
open drain): This field is intended for I2C functionality. See BROS 001-70428
for more details.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits)
and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell
replaces GPIO IO cell):
"0"/"2": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer
(PORT_VTRIP_SEL is '1')
"1"/"3": vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
"0": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL
is '1')
"1": vcchib.
"2": OVT.
"3": Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell
does not provide input buffer mode select functionality (SIOv2 IO cell
will replace SIO IO cell, as soon as it is available).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register
This register configures the IRQ configuration for all pins in a port,
with the IRQ type being individually pin-configurable.</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x001F000F</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide
a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register
An interrupt cause is cleared (set to '0') by writing a '1' to the corresponding
bit field. It is not recommended to write 0xff to clear all interrupt
causes, as a new interrupt cause may have occurred between reading the
register and clearing. Note that the interrupt cause fields and the associated
interrupt provide Hibernate functionality (interrupt causes can be set
to '1' and the interrupt can be activated in Hibernate power mode). The
PS_DATA fields reflect the logical IO pad states of the port (also found
in the PS register).</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x01030103</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description></description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here
to allow reading of both pin state and interrupt state of the port in
a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2
Configures the input disable for each pin.</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control
drive mode (PC.DM). This bit should be set when analog signals are present
on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register
Used to set output data of specific IO pads in the corresponding port
to '1', without affecting the output data of the other IO pads in the
port. A DR_SET register read returns the same value as a DR register read.</description>
            <addressOffset>0x40</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register
Used to clear output data of specific IO pads in the corresponding port
to '0', without affecting the output data of the other IO pads in the
port. A DR_CLR register read returns the same value as a DR register read.</description>
            <addressOffset>0x44</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register
Used to invert output data of specific IO pads in the corresponding port,
without affecting the output data of the other IO pads in the port. A
DR_INV register read returns the same value as a DR register read.</description>
            <addressOffset>0x48</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' => '1', '1' => '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>PRT1</name>
          <addressOffset>256</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register
Used to read and write the output data for the IO pads in the port. A
DR register write changes the output data to the written value. A DR register
read reflects the output data (and not the current state of the input
data for the IO pads). Using this DR register, Read-Modify-Write sequences
are safely performed on a port with some IO pads configured as inputs.</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register
Used to read. Writes to this register have no effect. If the drive mode
for the pin is set to high Z Analog, the state will read 0 independent
of the voltage on the pin.</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000001FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold,
logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will
read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register
Configures the output drive and input buffer state for each pin, and the
slew rate and input threshold selection for the whole port. One register
is provided per port.</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC3FFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as
I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before
turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage.
Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the
SIO register are used instead (a separate VTRIP_SEL is provided for each
pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits)
and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell
replaces GPIO IO cell):
"0"/"2": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer
(PORT_VTRIP_SEL is '1')
"1"/"3": vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
"0": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL
is '1')
"1": vcchib.
"2": OVT.
"3": Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell
does not provide input buffer mode select functionality (SIOv2 IO cell
will replace SIO IO cell, as soon as it is available).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register
This register configures the IRQ configuration for all pins in a port,
with the IRQ type being individually pin-configurable.</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x001FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide
a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register
An interrupt cause is cleared (set to '0') by writing a '1' to the corresponding
bit field. It is not recommended to write 0xff to clear all interrupt
causes, as a new interrupt cause may have occurred between reading the
register and clearing. Note that the interrupt cause fields and the associated
interrupt provide Hibernate functionality (interrupt causes can be set
to '1' and the interrupt can be activated in Hibernate power mode). The
PS_DATA fields reflect the logical IO pad states of the port (also found
in the PS register).</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x01FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA4</name>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA5</name>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA6</name>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA7</name>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description></description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here
to allow reading of both pin state and interrupt state of the port in
a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2
Configures the input disable for each pin.</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control
drive mode (PC.DM). This bit should be set when analog signals are present
on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register
Used to set output data of specific IO pads in the corresponding port
to '1', without affecting the output data of the other IO pads in the
port. A DR_SET register read returns the same value as a DR register read.</description>
            <addressOffset>0x40</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register
Used to clear output data of specific IO pads in the corresponding port
to '0', without affecting the output data of the other IO pads in the
port. A DR_CLR register read returns the same value as a DR register read.</description>
            <addressOffset>0x44</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register
Used to invert output data of specific IO pads in the corresponding port,
without affecting the output data of the other IO pads in the port. A
DR_INV register read returns the same value as a DR register read.</description>
            <addressOffset>0x48</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' => '1', '1' => '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>PRT2</name>
          <addressOffset>512</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register
Used to read and write the output data for the IO pads in the port. A
DR register write changes the output data to the written value. A DR register
read reflects the output data (and not the current state of the input
data for the IO pads). Using this DR register, Read-Modify-Write sequences
are safely performed on a port with some IO pads configured as inputs.</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register
Used to read. Writes to this register have no effect. If the drive mode
for the pin is set to high Z Analog, the state will read 0 independent
of the voltage on the pin.</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000010F</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold,
logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will
read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register
Configures the output drive and input buffer state for each pin, and the
slew rate and input threshold selection for the whole port. One register
is provided per port.</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC3000FFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as
I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before
turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage.
Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the
SIO register are used instead (a separate VTRIP_SEL is provided for each
pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits)
and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell
replaces GPIO IO cell):
"0"/"2": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer
(PORT_VTRIP_SEL is '1')
"1"/"3": vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
"0": CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL
is '1')
"1": vcchib.
"2": OVT.
"3": Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell
does not provide input buffer mode select functionality (SIOv2 IO cell
will replace SIO IO cell, as soon as it is available).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register
This register configures the IRQ configuration for all pins in a port,
with the IRQ type being individually pin-configurable.</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x001F00FF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide
a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register
An interrupt cause is cleared (set to '0') by writing a '1' to the corresponding
bit field. It is not recommended to write 0xff to clear all interrupt
causes, as a new interrupt cause may have occurred between reading the
register and clearing. Note that the interrupt cause fields and the associated
interrupt provide Hibernate functionality (interrupt causes can be set
to '1' and the interrupt can be activated in Hibernate power mode). The
PS_DATA fields reflect the logical IO pad states of the port (also found
in the PS register).</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x010F010F</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>DATA3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description></description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here
to allow reading of both pin state and interrupt state of the port in
a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2
Configures the input disable for each pin.</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control
drive mode (PC.DM). This bit should be set when analog signals are present
on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register
Used to set output data of specific IO pads in the corresponding port
to '1', without affecting the output data of the other IO pads in the
port. A DR_SET register read returns the same value as a DR register read.</description>
            <addressOffset>0x40</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register
Used to clear output data of specific IO pads in the corresponding port
to '0', without affecting the output data of the other IO pads in the
port. A DR_CLR register read returns the same value as a DR register read.</description>
            <addressOffset>0x44</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register
Used to invert output data of specific IO pads in the corresponding port,
without affecting the output data of the other IO pads in the port. A
DR_INV register read returns the same value as a DR register read.</description>
            <addressOffset>0x48</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' => '1', '1' => '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field
reflects the IO port's interrupt line (bit field i reflects "gpio_interrupts[i]"
for IO port i). The register is used when the system uses a shared/combined
interrupt line "gpio_interrupt". The SW ISR reads the register to deternine
which IO port(s) is responsible for the shared/combined interrupt line
"gpio_interrupt". Once, the IO port(s) is determined, the IO port's INTR
register is read to determine the IO pad(s) in the IO port that caused
the interrupt.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_IO_TEST</name>
          <description>IO SELF TEST control register for DfT purposes only
This register is used to significantly reduce the test time for IO cells.
It also avoids the need to develop a large amount of chip specific functional
test vectors.
With ATPG it is not possible to get full stuck-at fault coverage for some
IO cell inputs (�hld_ovr, oe_n, analog_en, analog_sel, analog_pol�). This
register gives direct controlabilty on those  inputs of all IO cells by
bypassing the functional paths. That allows generic (not chip specific)
ROOS code (also SWD IO cells are included) to get DfT fault-coverage for
these signals. This register is used in conjunction with the GPIO.PC.dm[2:0],
GPIO.DR.out and SRSS.CORE.PWR_STOP.FREEZE for control and results are
observed through GPIO.PS.data.
Only one IO cell on the whole chip gets IO_TEST_0  and only one gets IO_TEST_1
and default values of IO_TEST_0 is '0' and IO_TEST_1 is '1'. Also only
one IO cell on the whole chip gets asssigned ADFT-0 and only one gets
asssigned ADFT-1. All four IO_TEST_0/1 and ADFT-0/1 pins are assigned
in the product pin spreadsheet.</description>
          <addressOffset>0x1010</addressOffset>
          <resetValue>0x02020200</resetValue>
          <resetMask>0x1F1F1F03</resetMask>
          <fields>
            <field>
              <name>DFT_IO_TEST_MODE</name>
              <description>DfT IO SELF TEST mode:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ADFT</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ANA</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_GEN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_HLD_OVR_0</name>
              <description>�hld_ovr� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �hld_ovr� of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to �hld_ovr� of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_0</name>
              <description>�oe_n� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �oe_n� of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to �oe_n� of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_0</name>
              <description>�analog_en� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_en� of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to �analog_en� of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_0</name>
              <description>�analog_sel� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_sel� of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to �analog_sel� of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_0</name>
              <description>�analog_pol� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_pol� of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to �analog_pol� of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_1</name>
              <description>�hld_ovr� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �hld_ovr� of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to �hld_ovr� of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_1</name>
              <description>�oe_n� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �oe_n� of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to �oe_n� of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_1</name>
              <description>�analog_en� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_en� of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to �analog_en� of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_1</name>
              <description>�analog_sel� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_sel� of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to �analog_sel� of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_1</name>
              <description>�analog_pol� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_pol� of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to �analog_pol� of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_2</name>
              <description>�hld_ovr� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �hld_ovr� of all IO cells other than ADFT-0/1 .
TEST_ANA: Connects to �hld_ovr� of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to �hld_ovr� of all IO cells.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_2</name>
              <description>�oe_n� DfT control for IO cells depending on DFT_IO_TEST_MODE as given
below.
TEST_ADFT: Connects to �oe_n� of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to �oe_n� of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to �oe_n� of all IO cells</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_2</name>
              <description>�analog_en� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_en� of all IO cells other than ADFT-0/1.
TEST_ANA: DFT_ANALOG_EN_2 &amp;&amp; DM[0] connects to �analog_en� of all IO cells
other than IO_TEST_0/1.
TEST_GEN: Connects to �analog_en� of all IO cells</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_2</name>
              <description>�analog_sel� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_sel� of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to �analog_sel� of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to �analog_sel� of all IO cells.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_2</name>
              <description>�analog_pol� DfT control for IO cells depending on DFT_IO_TEST_MODE as
given below.
TEST_ADFT: Connects to �analog_pol� of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to �analog_pol� of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to �analog_pol� of all IO cells.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SCB0</name>
        <value>6</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x0300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>Serial interface bit period oversampling factor expressed in lP clock
cycles. Used for SPI and UART functionality. OVS + 1 IP clock cycles constitute
a single serial interface clock/bit cycle. The IP clock is provided by
the programmable clock IP. This field is NOT used in externally clocked
mode. If OVS is odd, the oversampling factor is even and the first and
second phase of the interface clock period are the same. If OVS is even,
the oversampling factor is odd and the first phase of the interface clock
period is 1 peripheral clock cycle longer than the second phase of the
interface clock period.
In SPI master mode, the valid range is [3, 15]. At an IP frequency of
48 MHz, the maximum IP bit rate is 12 Mbps. The effective system bit rate
is dependent on the external SPI slave that we communicate with. If the
SPI output clock "spi_clk_out" to SPI MISO input "spi_miso_in" round trip
delay is introducing significant delays (multiple "spi_clk_out" cycles),
it may be necessary to increase OVS and/or to set SPI_CTRL.LATE_MISO_SAMPLE
to '1' to achieve the maximum possible system bit rate. The maximum IP
bit rate of 12 Mbps provides an IP centric perspective, assuming ideal
(0 ns) IO cell and routing (chip and board) delay. The required IP clock/IF
clock ratio increases and the calculated maximum bit rate decreases, when
realistic chip and routing delays are taken into account.
In SPI slave mode, the OVS field is NOT used. However, there is a frequency
requirement for the IP clock wrt. the interface (IF) clock to guarantee
functional correct behavior. This requirement is expressed as a ratio:
IP clock/IF clock. The ratio is dependent on the setting of RX_CTRL.MEDIAN
and the external SPI master's capability to support "late MISO sample"
functionality (similar to our SPI master functionality represented by
SPI_CTRL.LATE_MISO_SAMPLE):
- MEDIAN is '0' and external SPI master has NO "late MISO sample functionality":
IP clock/IF clock >= 6. At a IP frequency of 48 MHz,  the maximum bit
rate is 8 Mbps.
- MEDIAN is '0' and external SPI master has "late MISO sample functionality":
IP clock/IF clock >= 3. At a IP frequency of 48 MHz,  the maximum bit
rate is 16 Mbps.
- MEDIAN is '1' and external SPI master has NO "late MISO sample functionality":
IP clock/IF clock >= 8. At a IP frequency of 48 MHz,  the maximum bit
rate is 6 Mbps.
- MEDIAN is '1' and external SPI master has "late MISO sample functionality":
IP clock/IF clock >= 4. At a IP frequency of 48 MHz,  the maximum bit
rate is 12 Mbps.
The maximum bit rates provide an IP centric perspective, assuming ideal
(0 ns) IO cell and routing (chip and board) delay. The required IP clock/IF
clock ratio increases and the calculated maximum bit rate decreases, when
realistic chip and routing delays are taken into account.
In UART standard submode (including LIN), the valid range is [7, 15].
In UART SmartCard submode, the valid range is [7, 15].
In UART TX IrDA submode this field indirectly specifies the oversampling.
The oversampling determines the interface clock/bit cycle and the width
of the pulse.  Only normal transmission mode is supported, the pulse is
roughly 3/16 of the bit period (for all bit rates). There is only one
valid OVS value:
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
           IP clock frequency of 16*57.6 KHz for 57.6 Kbps.
           IP clock frequency of 16*38.4 KHz for 38.4 Kbps.
           IP clock frequency of 16*19.2 KHz for 19.2 Kbps.
           IP clock frequency of 16*9.6 KHz for 9.6 Kbps.
           IP clock frequency of 16*2.4 KHz for 2.4 Kbps.
           IP clock frequency of 16*1.2 KHz for 1.2 Kbps.
- all other values are not used in normal mode.
In UART RX IrDA submode (1.2, 2.4, 9.6, 19.2, 38.4, 57.6 and 115.2 Kbps)
this field indirectly specifies the oversampling. The oversampling determines
the interface clock/bit cycle and the width of the pulse. In normal transmission
mode, this pulse is roughly 3/16 of the bit period (for all bit rates).
In low power transmission mode, this pulse is potentially smaller (down
to 1.62 us typical and 1.41 us minimal) than 3/16 of the bit period (for
&lt; 115.2 Kbps bitrates). Pulse widths greater or equal than two IP clock
cycles are guaranteed to be detected by the receiver. Pulse widths less
than two IP clock cycles and greater or equal than one IP clock cycle
may be detected by the receiver. Pulse widths less than one IP clock cycle
will not be detected by the receiver. RX_CTRL.MEDIAN should be set to
'1' for IrDA receiver functionality. The IP clock (as provided by the
programmable clock IP) and the oversampling together determine the IrDA
bitrate. Normal mode, OVS field values (with the required IP clock frequency):
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
           IP clock frequency of 16*57.6 KHz for 57.6 Kbps.
           IP clock frequency of 16*38.4 KHz for 38.4 Kbps.
           IP clock frequency of 16*19.2 KHz for 19.2 Kbps.
           IP clock frequency of 16*9.6 KHz for 9.6 Kbps.
           IP clock frequency of 16*2.4 KHz for 2.4 Kbps.
           IP clock frequency of 16*1.2 KHz for 1.2 Kbps.
- all other values are not used in normal mode.
Low power mode, OVS field values (with the required IP clock frequency):
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
- 1: 32 times oversampling.
           IP clock frequency of 32*57.6 KHz for 57.6 Kbps.
- 2: 48 times oversampling.
           IP clock frequency of 48*38.4 KHz for 38.4 Kbps.
- 3: 96 times oversampling.
           IP clock frequency of 96*19.2 KHz for 19.2 Kbps.
- 4: 192 times oversampling.
           IP clock frequency of 192*9.6 KHz for 9.6 Kbps.
- 5: 768 times oversampling.
           IP clock frequency of 768*2.4 KHz for 2.4 Kbps.
- 6: 1536 times oversampling.
           IP clock frequency of 1536*1.2 KHz for 1.2 Kbps.
- all other values are not used in low power mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address
matching (I2C) or selection (SPI). In internally clocked mode, the serial
interface protocols run off the peripheral clock. In externally clocked
mode, the serial interface protocols run off the clock as provided by
the serial interface. Externally clocked mode is only used for synchronous
serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only
Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation.
In internally clocked mode, the serial interface protocols run off the
peripheral clock. In externally clocked mode, the serial interface protocols
run off the clock as provided by the serial interface. Externally clocked
operation mode is only used for synchronous serial interface protocols
(SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode
(all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave,
EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP
will degrade the effective bitrate).
In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied
to the serial interface protocol. This meta protocol adds meaning to the
data frames transferred by the serial interface protocol: a data frame
can represent a memory address, a write memory data element or a read
memory data element. EZ mode is only used for synchronous serial interface
protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola
modes: 0, 1, 2, 3) is supported and the transmitter should use continuous
data frames; i.e. data frames mot seperated by slave deselection. This
mode is only applicable to slave functionality. In EZ mode, the slave
can read from and write to an addressable memory structure of 32 bytes.
In EZ mode, data frames should 8-bit in size and should be transmitted
and received with the Most Significant Bit (MSB) first.
In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries,
but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to
be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO
('1') or not ('0').
In I2C mode, this field is used to allow the slave to put the received
slave address or general call address in the RX FIFO. Note that a received
matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both
I2C read and write transfers.
In multi-processor UART receiver mode, this field is used to allow the
receiver to put the received address in the RX FIFO. Note: non-matching
addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic
and the MMIO SW accesses to EZ memory coincide/collide, this bit determines
whether a SW access should block and result in bus wait states ('BLOCK
is 1') or not (BLOCK is '0'). IF BLOCK is �0� and the accesses collide,
MMIO read operations return 0xffff:ffff and MMIO write operations are
ignored. Colliding accesses are registered as interrupt causes: field
BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Mode of operation (3: Reserved)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize
the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and
UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of
a submode, master/slave functionality and transmitter/receiver functionality
when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information.
This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL)
information.
- Program CTRL to enable IP, select the specific operation mode and oversampling
factor.
When the IP is enabled, no control information should be changed. Changes
should be made AFTER disabling the IP, e.g. to modify the operation mode
(from I2C to SPI) or to go from externally to internally clocked. The
change takes effect after the IP is re-enabled. Note that disabling the
IP will cause re-initialization of the design and associated state is
lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory (this is only possible in EZ mode). This bit can be used
by SW to determine whether it is safe to issue a SW access to the EZ memory
(without bus wait states (a blocked SW access) or bus errors being generated).
Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are
used to indicate whether a SW access was actually blocked by externally
clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control register.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001F001F</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C
CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode
read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR
is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified
during ongoing bus transfers.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C
CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode
write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR
is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified
during ongoing bus transfers.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status register.
The register fields reflect register states without a default/reset value
(CURR_RD_ADDR and CURR_WR_ADDR) or reflect an external bus state. Therefore,
these registers are undefined after the IP is enabled.</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field
after a read access to the memory buffer. However, when the last memory
buffer address is reached, the address is NOT incremented (but remains
at the maximim memory buffer address).
The field is used to determine how many bytes have been read (# bytes
= CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR).
This field is reliable during when there is no bus transfer. This field
is potentially unreliable when there is a bus transfer bus transfer: when
CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field
after a read access to the memory buffer. However, when the last memory
buffer address is reached, the address is NOT incremented (but remains
at the maximim memory buffer address).
The field is used to determine how many bytes have been written (# bytes
= CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
This field is reliable during when there is no bus transfer. This field
is potentially unreliable when there is a bus transfer bus transfer: when
CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transferr.
For SPI, the field is '1' when the slave is selected.
For I2C, the field is set to '1' at a I2C START/RESTART. In case of an
address match, the  field is set to '0' on a I2C STOP. In case of NO address
match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register
are reliable (CMD_RESP_EC_BUSY is '0') or not reliable (CMD_RESP_EC_BUSY
is '1'). Note:
- When there is no bus transfer, CMD_RESP_EC_BUSY is '0'.
- When there is a bus transfer, CMD_RESP_EC_BUSY is '0', when the CURR_RD_ADDR
and CURR_WR_ADDR are not updated by the HW.
- When there is a bus transfer, CMD_RESP_EC_BUSY is '1', when the CURR_RD_ADDR
or CURR_WR_ADDR are updated by the HW. Note that this update lasts a single
serial interface clock cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control register.</description>
          <addressOffset>0x20</addressOffset>
          <resetValue>0x03000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is
used in master mode. In slave mode, both continuous and non-continuous
SPI data transfers are supported independent of this field.
When continuous transfers are enabled individual data frame transfers
are not necessarily seperated by slave deselection (as indicated by the
level or pulse on the SELECT line): if the TX FIFO has multiple data frames,
data frames are send out without slave deselection.
When continuous transfers are not enabled individual data frame transfers
are always seperated by slave deselection: independent of the availability
of TX FIFO data frames, data+G65 frames are send out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.
When '1', the data frame start indication is a pulse on the SELECT line
that precedes the transfer of the first data frame bit.
When '0', the data frame start indication is a pulse on the SELECT line
that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock phase. This
field, together with the CPOL field, indicates when MOSI data is driven
and MISO data is captured:
- Motorola mode 0. CPOL is �0�, CPHA is �0�: MOSI  is driven on a falling
edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is �0�, CPHA is �1�: MOSI  is driven on a rising
edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is �1�, CPHA is �0�: MOSI  is driven on a rising
edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is �1�, CPHA is �1�: MOSI  is driven on a falling
edge of SCLK. MISO is captured on a rising edge of SCLK.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. Only used in SPI Motorola submode. This
field, together with the CPHA field, indicates when MOSI data is driven
and MISO data is captured:
- CPOL is �0�: SCLK is �0� when not transmitting data.
- CPOL is �1�: SCLK is �1� when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
When '0', the default applies (for Motorola as determined by CPOL and
CPHA, for Texas Instruments on the falling edge of SCLK and for National
Semiconductors on the rising edge of SCLK).
When '1', the alternate clock edge is used (which comes half a SPI SCLK
period later). Late sampling addresses the round trip delay associated
with transmitting SCLK from the master to the slave and transmitting MISO
from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode.
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful
for slave devices that use SCLK for functional operation other than just
SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave
select signal 0 (master mode) and to the incoming SPI slave select signal
(slave mode). For Motorola and National Semiconductors submodes:
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Istruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity. SSEL_POLARITY1 applies to the outgoing SPI slave
select signal 1 (master mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity. SSEL_POLARITY2 applies to the outgoing SPI slave
select signal 2 (master mode).</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity. SSEL_POLARITY3 applies to the outgoing SPI slave
select signal 3 (master mode).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line "spi_miso_in" is connected to the SPI MISO
pin.
'1': the SPI master MISO line "spi_miso_in" is connected to the SPI master
MOSI line "spi_mosi_out". In other words, in loopback mode the SPI master
receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of SPI operation (3: Reserved).</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four outgoing SPI slave select signals:
- 0: Slave 0, SPI_SELECT[0].
- 1: Slave 1, SPI_SELECT[1].
- 2: Slave 2, SPI_SELECT[2].
- 3: Slave 3, SPI_SELECT[3].
Only used in master mode. The IP should be disabled when changes are made
to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence
on availability of data frames in the TX FIFO. In slave mode, when selected
and there is no data frame in the TX FIFO, the slave will transmit all
'1's. In both master and slave modes, received data frames will be lost
if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status register.</description>
          <addressOffset>0x24</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction.
For Motorola and National submodes, the busy bit is '1', when the slave
selection (low active) is activated. For TI submode, the busy bit is '1'
from the time the preceding/coinciding slave select (high active) is activated
for the first transmitted data frame, till the last MOSI/MISO bit of the
last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible
in EZ mode). This bit can be used by SW to determine whether BASE_ADDR
and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable
in internally clocked mode. In externally clocked mode the field may be
unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock
domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This
field is only reliable in internally clocked mode. In externally clocked
mode the field may be unreliable, as clock domain synchronization is not
performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control register.</description>
          <addressOffset>0x40</addressOffset>
          <resetValue>0x03000000</resetValue>
          <resetMask>0x03010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
When '0', the transmitter TX line "uart_tx_out" is connected to the TX
pin and the receiver RX line "uart_rx_in" is connected to the RX pin.
When '1', the transmitter TX line "uart_tx_out" is connected to the receiver
RX line "uart_rx_in". A similar connections scheme is followed for "uart_rts_out"
and "uart_cts_in".
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of UART operation (3: Reserved)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control register.</description>
          <addressOffset>0x44</addressOffset>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x00000137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of
halve bit periods. Valid range is [1, 7]; i.e. a stop period should last
at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1',
the transmitter generates an odd parity. Only applicable in standard UART
and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard
UART submodes. In SmartCard submode, parity generation is always enabled
through hardware. In IrDA submode, parity generation is always disabled
through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement
is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control register.</description>
          <addressOffset>0x48</addressOffset>
          <resetValue>0x000A0002</resetValue>
          <resetMask>0x000F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of
halve bit periods. Valid range is [1, 7]; i.e. a stop period should last
at least one bit period. If STOP_BITS is '1', stop bits error detection
is NOT performed. If STOP_BITS is in [2, 7], stop bits error detection
is performed and the associated interrupt cause INTR_RX.FRAME_ERROR is
set to '1' if an error is detected. In other words, the receiver supports
data frames with a 1 bit period stop bit sequence, but requires at least
1.5 bit period stop bit sequences to detect errors. This limitation is
due to possible transmitter and receiver clock skew that prevents the
design from doing reliable stop bit detection for short (1 bit bit period)
stop bit sequences. Note that in case of a stop bits error, the successive
data frames may get lost as the receiver needs to resynchronize its start
bit detection. The amount of lost data frames depends on both the amount
of stop bits, the idle ('1') time between data frames and the data frame
value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the
receiver expects an odd parity. Only applicable in standard UART and SmartCard
submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard
UART submode. In SmartCard submode, parity checking is always enabled
through hardware. In IrDA submode, parity checking is always disabled
through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal "uart_rx_in". Inversion is after local
loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to
the RX FIFO. When '1', received data is dropped and lost. Only applicable
in standard UART and SmartCard submodes (negatively acknowledged SmartCard
data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0',
received data is send to the RX FIFO. When '1', received data is dropped
and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this
mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor
mode, the 9th received bit of a data frame seperates addresses (bit is
'1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA
and RX_MATCH.MASK. In the case of a match, subsequent received data are
sent to the RX FIFO. In the case of NO match, subsequent received data
are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs
break detection and baud rate detection on the incoming data. First, break
detection counts the amount of bit periods that have a line value of '0'.
BREAK_WIDTH specifies the minum required amount of bit periods. Successful
break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'.
Second, baud rate detection counts the amount of peripheral clock periods
that are use to receive the synchronization byte (0x55; least significant
bit first). The count is available through UART_RX_STATUS.BR_COUNTER.
Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt
cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine
the receiver clock to the transmitter clock. The receiver software can
use the BR_COUNTER value to set the right IP clock (from the programmable
clock IP) to guarantee successful receipt of the first LIN data frame
(Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips
start bit detection for the first received data frame. Instead, it synchronizes
on the first received data frame bit, which should be a '1'. This functionality
is intended for wake up from DeepSleep when receiving a data frame. The
transition from idle ('1') to START ('0') on the RX line is used to wake
up the CPU. The transition detection (and the associated wake up functionality)
is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART
receiver functionality. Once enabled, it is assumed that the START bit
is ongoing (the CPU wakeup and SCB enable time should be less than the
START bit period). The SCB will synchronize to a '0' to '1' transition,
which indicates the first data frame bit is received (first data frame
bit should be '1'). After synchronization to the first data frame bit,
the SCB will resume normal UART functionality: subsequent data frames
will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a
break. During a break the transmitted/received line value is '0'. This
feature is useful for standard UART submode and LIN submode ("break field"
detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit
is set to '1'. Note that break detection precedes baud rate detection,
which is used to synchronize/refine the receiver clock to the transmitter
clock. As a result, break detection operates with an unsynchronized/unrefined
receiver clock. Therefore, the receiver's definition of a bit period is
imprecise and the setting of this field should take this imprecision into
account. The LIN standard also accounts for this imprecision: a LIN start
bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods
during regular transmission, whereas the LIN break detection should be
at least 13 consecutive '0' bit periods. This provides for a margin of
4 bit periods. Therefore, the default value of this field is set to 10,
representing a minimal break field with of 10+1 = 11 bit periods; a value
in between the 9 consecutive bit periods of a regular transmission and
the 13 consecutive bit periods of a break field. This provides for slight
imprecisions of the receiver clock wrt. the transmitter clock. There should
not be a need to program this field to any value other than its default
value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status register.</description>
          <addressOffset>0x4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of
a 0x55 data frame (sent least signficant bit first) as determined by the
receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that
constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT
is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control register
UART flow control is a design time configuration parameter, which make
the presence of this MMIO register conditional to the configuration. The
"uart_rts_out" and "uart_cts_in" are always present on the IP interface.
If flow control is configured out, "uart_rts_out" is NOT connected, and
"uart_cts_in" should be connected to '0'.</description>
          <addressOffset>0x50</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0301000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount
of this field, a Ready To Send (RTS) output signal "uart_rts_out" is activated.
By setting this field to "0", flow control is effectively SW disabled
(may be useful for debug purposes).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal "uart_rts_out":
'0': RTS is low/'0' active; "uart_rts_out" is '0' when active and "uart_rts_out"
is '1' when inactive.
'1': RTS is high/'1' active; "uart_rts_out" is '1' when active and "uart_rts_out"
is '0' when inactive.
During IP reset (Hibernate system power mode), "uart_rts_out" is '1'.
This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal "uart_cts_in":
'0': CTS is low/'0' active; "uart_cts_in" is '0' when active and "uart_cts_in"
is '1' when inactive.
'1': CTS is high/'1' active; "uart_cts_in" is '1' when active and "uart_cts_in"
is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal "uart_cts_in" by the UART transmitter:
'0': Disabled. The UART transmitter ignores "uart_cts_in", and transmits
when a data frame is available for transmission in the TX FIFO or the
TX shift register.
'1': Enabled. The UART transmitter uses "uart_cts_in" to qualify the transmission
of data. It transmits when "uart_cts_in" is active and a data frame is
available for transmission in the TX FIFO or the TX shift register.
If UART_CTRL.LOOPBACK is '1', "uart_cts_in" is connected to "uart_rts_out"
in the IP (both signals are subjected to signal polarity changes are indicated
by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control register.</description>
          <addressOffset>0x60</addressOffset>
          <resetValue>0x0000FB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS +
1 peripheral clock periods constitute the high phase of a bit period.
The valid range is [5, 15] with input signal median filtering and [4,
15] without input signal median filtering.
The field is only used in master mode. In slave mode, the field is NOT
used. However, there is a frequency requirement for the IP clock wrt.
the regular interface (IF) high time to guarantee functional correct behavior.
With input signal median filtering, the IF high time should be >= 6 IP
clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering,
the IF high time should be >= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1
peripheral clock periods constitute the low phase of a bit period. The
valid range is [7, 15] with input signal median filtering and [6, 15]
without input signal median filtering.
The field is only used in master mode. In slave mode, the field is NOT
used. However, there is a frequency requirement for the IP clock wrt.
the regular (no stretching) interface (IF) low time to guarantee functional
correct behavior. With input signal median filtering, the IF low time
should be >= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input
signal median filtering, the IF low time should be >= 7 IP clock cycles
and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when
the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd
when the receiver FIFO is full. When '0', clock stretching is used instead
(till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd
(no ACK or clock stretching) and treated as a non matching slave address.
This is useful for slaves that do not need any data supplied within the
general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when
the receiver FIFO is not full. In EZ mode, this field should be set to
'1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when
the receiver FIFO is not full. In EZ mode, this field should be set to
'1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address
match or general call address (and S_GENERAL_IGNORE is '0'). Only used
when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the
receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer
full).
For externally clocked logic (EC_AM is '1') on an address match or general
call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when
EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately
NACK'd. There are two possibilities: 1). the internally clocked logic
is enabled (we are in Active system power mode) and it handles the rest
of the current transfer. In this case the I2C master will not observe
the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep
system power mode). In this case the I2C master will observe the NACK
and may retry the transfer in the future (which gives the internally clocked
logic the time to wake up from DeepSleep system power mode).
- 0: clock stretching is performed (till the internally clocked logic
takes over). The internally clocked logic will handle the ongoing transfer
as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when
the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer
full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines
are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines
are routed internally in the peripheral, and as a result unaffected by
other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave
modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status register.</description>
          <addressOffset>0x64</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000031</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START
is detected or from the time the SCL line is '0'. The bus is considered
idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY
is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect
a busy bus. This time is the maximum high time of the SCL line. For a
100 kHz interface frequency, this maximum high time may last roughly 5
us (half a bit period).
For single master systems, BUS_BUSY does not have to be used to detect
an idle bus before a master starts a transfer using I2C_M_CMD.M_START
(no bus collisions).
For multi-master systems, BUS_BUSY can be used to detect an idle bus before
a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent
bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible
in EZ mode). This bit can be used by SW to determine whether BASE_ADDR
and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When
the I2C slave is inactive/idle or receiving START, REPEATED START, STOP
or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When
the I2C master is inactive/idle or transmitting START, REPEATED START,
STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only
reliable in internally clocked mode. In externally clocked mode the field
may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'),
as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer.
This field is only reliable in internally clocked mode. In externally
clocked mode the field may be unreliable, as clock domain synchronization
is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode.</description>
          <addressOffset>0x68</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED
START is transmitted depends on the state of the master state machine.
A START is only transmitted when the master state machine is in the default
state. A REPEATED START is transmitted when the master state machine is
not in the default state, but is working on an ongoing transaction. The
REPEATED START can only be transmitted after a NACK or ACK has been received
for a transmitted data element or after a NACK has been transmitted for
a received data element. When this action is performed, the hardware sets
this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY
is '0', note that BUSY has a default value of '0'). For bus idle detection
the hardware relies on STOP detection. As a result, bus idle detection
is only functional after at least one I2C bus transfer has been detected
on the bus (default/reset value of BUSY is '0') . A START is only transmitted
when the master state machine is in the default state. When this action
is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action
is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When
this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the
hardware sets this field to '0'. This command has a higher priority than
I2C_M_CMD.M_START: in situations where both a STOP and a REPEATED START
could be transmitted, M_STOP takes precedence over M_START.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode.</description>
          <addressOffset>0x6C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action
is performed, the hardware sets this field to '0'. In EZ mode, this field
should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When
this action is performed, the hardware sets this field to '0'.  In EZ
mode, this field should be set to '0' (it is only to be used in non EZ
mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK
or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration register.
The filters are used to remove glitches and to guarantee I2C compliant
SCL and SDA setup and hold times. The filters are trimmable.</description>
          <addressOffset>0x70</addressOffset>
          <resetValue>0x002A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for "i2c_sda_in" 50 ns filter. See s8i2cs BROS (001-59539) for
more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of "i2c_sda_in" filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for "i2c_scl_in" 50 ns filter. See s8i2cs BROS (001-59539) for
more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of "i2c_scl_in" filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 0. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 1. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 2. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative "i2c_sda_out" filter delay:
"0": 0 ns.
"1": 50 ns (filter 0 enabled).
"2": 100 ns (filters 0 and 1 enabled).
"3": 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control register.</description>
          <addressOffset>0x200</addressOffset>
          <resetValue>0x00000107</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted
data frame. This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8]. For SPI, the valid range is
[3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1').
For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register.</description>
          <addressOffset>0x204</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number
of this field, a transmitter trigger event is generated.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated.
Invalidation will last for as long as this field is '1'. If a quick clear/invalidation
is required, the field should be set to '1' and be followed by a set to
'0'. If a clear/invalidation is required for an extended time period,
the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO
entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register.
This register is not used in EZ and CMD_RESP modes.</description>
          <addressOffset>0x208</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F801F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the transmitter FIFO. The value of this field ranges
from 0 to FF_DATA_NR.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1')
or not ('0'). The shift register can be considered the top of the TX FIFO
(the data frame is not included in the USED field of the TX FIFO). The
shift register is a working register and holds the data frame that is
currently transmitted (when the protocol state machine is transmitting
a data frame) or the data frame that is tranmitted next (when the protocol
state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the
hardware.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write register.
When the IP is disabled (CTRL.ENABLED is '0') or when the TX FIFO is full,
a write to this register is dropped. This register should only be used
in FIFO mode (and not in EZ or CMD_RESP modes). This register is "write
only"; a read from this register returns "0".</description>
          <addressOffset>0x240</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that
of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0]
are used.
A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control register.</description>
          <addressOffset>0x300</addressOffset>
          <resetValue>0x00000107</resetValue>
          <resetMask>0x0000030F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received
data frame. This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8]. For SPI, the valid range is
[3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and
I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1').
For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on
input interface lines. This filter should reduce the susceptability to
errors. However, its requires higher oversampling values. For UART IrDA
submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register.</description>
          <addressOffset>0x304</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number
of this field, a receiver trigger event is generated.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated.
Invalidation will last for as long as this field is '1'. If a quick clear/invalidation
is required, the field should be set to '1' and be followed by a set to
'0'. If a clear/invalidation is required for an extended time period,
the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze
will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status register.
This register is not used in EZ and CMD_RESP modes.</description>
          <addressOffset>0x308</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F801F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the receiver FIFO. The value of this field ranges
from 0 to FF_DATA_NR.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data
frame ('1') or not ('0'). The shift register can be considered the bottom
of the RX FIFO (the data frame is not included in the USED field of the
RX FIFO). The shift register is a working register and holds the data
frame that is currently being received (when the protocol state machine
is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written
by the hardware.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask register.</description>
          <addressOffset>0x310</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.
In UART multi-processor mode, all 8 bits are used.
In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization
of the first transmitted byte in a I2C transfer: the first 7 bits represent
the address of the addressed slave, and the last 1 bit is a read/write
indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of
the ADDR field bits in the ADDR field take part in the matching of the
slave address: MATCH = ((ADDR &amp; MASK) == ("slave address" &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read register.
When the IP is disabled (CTRL.ENABLED is '0') or when the RX FIFO is empty,
a read from this register returns 0xffff:ffff. This register should only
be used in FIFO mode (and not in EZ or CMD_RESP modes). This register
is "read only"; a write to this register is ignored.</description>
          <addressOffset>0x340</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the
data frame from the FIFO; i.e. behavior is similar to that of a POP operation.
Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
This register has a side effect when read by software: a data frame is
removed from the FIFO. This may be undesirable during debug; i.e. a read
during debug should NOT have a side effect. To this end, the IP uses the
AHB-Lite "hmaster[0]" input signal. When this signal is '1' in the address
cycle of a bus transfer, a read transfer will not have a side effect.
As a result, a read from this register will not remove a data frame from
the FIFO. As a result, a read from this register behaves as a read from
the SCB_RX_FIFO_RD_SILENT register.
A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read register.
When the IP is disabled (CTRL.ENABLED is '0') or when the RX FIFO is empty,
a read from this register returns 0xffff:ffff. This register should only
be used in FIFO mode (and not in EZ or CMD_RESP modes).</description>
          <addressOffset>0x344</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove
the data frame from the FIFO; i.e. behavior is similar to that of a PEEK
operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA0</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x400</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA1</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x404</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA2</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x408</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA3</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x40C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA4</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x410</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA5</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x414</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA6</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x418</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA7</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x41C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA8</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x420</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA9</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x424</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA10</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x428</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA11</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x42C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA12</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x430</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA13</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x434</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA14</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x438</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA15</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x43C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA16</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x440</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA17</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x444</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA18</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x448</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA19</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x44C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA20</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x450</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA21</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x454</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA22</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x458</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA23</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x45C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA24</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x460</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA25</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x464</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA26</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x468</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA27</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x46C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA28</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x470</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA29</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x474</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA30</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x478</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA31</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x47C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal register
Enables software to determine the source of the combined interrupt output
signals "interrupt_ic", "interrupt_ec" and "interrupt".</description>
          <addressOffset>0xE00</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ("interrupt_master"): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ("interrupt_slave"): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ("interrupt_tx"): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ("interrupt_rx"): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ("interrupt_i2c_ec"): INTR_I2C_EC_MASKED
!= 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ("interrupt_spi_ec"): INTR_SPI_EC_MASKED
!= 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register
The fields in this register are set by HW and are cleared by software
by writing a '1'.  These interrupt causes are generated by externally
clocked logic. HW clears the interrupt causes to '0', when the IP is disabled.</description>
          <addressOffset>0xE80</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).
Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of
a write transfer (I2C STOP). This event is an indication that a buffer
memory location has been written to. For EZ mode: a  transfer that only
writes the base address does NOT activate this event.
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of
a read transfer (I2C STOP). This event is an indication that a buffer
memory location has been read from.
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0xE88</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_I2C_EC_MASKED != 0.</description>
          <addressOffset>0xE8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register
The fields in this register are set by HW and are cleared by software
by writing a '1'. These interrupt causes are generated by externally clocked
logic. HW clears the interrupt causes to '0', when the IP is disabled.</description>
          <addressOffset>0xEC0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked
selection is '1'.
Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of
a write transfer (SPI deselection). This event is an indication that a
buffer memory location has been written to. For EZ mode: a  transfer that
only writes the base address does NOT activate this event.
Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of
a read transfer (SPI deselection). This event is an indication that a
buffer memory location has been read from.
Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0xEC8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_SPI_EC_MASKED != 0.</description>
          <addressOffset>0xECC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).
The interrupt causes should only be used for internally clocked operation;
i.e. EC_OP is '0'.</description>
          <addressOffset>0xF00</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA
line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives
a NACK (typically after the master transmitted the slave address or TX
data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK
(typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are
sent and the transmit FIFO is empty.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request register
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF04</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask register.</description>
          <addressOffset>0xF08</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_M_MASKED != 0.</description>
          <addressOffset>0xF0C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).
The interrupt causes should only be used for internally clocked operation;
i.e. EC_OP is '0'.</description>
          <addressOffset>0xF40</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the
same as the value observed on the SDA line (while the SCL line is '1').
This should not occur, it represents erroneous I2C bus behavior. In case
of lost arbitration, the I2C slave state machine abort the ongoing transfer.
The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave
receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives
a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address
matching is performed). Set to '1', when STOP or REPEATED START event
is detected. The REPEATED START event is included in this interrupt cause
such that the I2C transfers separated by a REPEATED START can be distinguished
and potentially treated separately by the Firmware. Note that the second
I2C transfer (after a REPEATED START) may be to a different slave address.
In non EZ mode, the event is detected on any I2C write transfer intended
for this slave. Note that a I2C write address intended for the slave (address
is matching and a it is a write transfer) will result in a I2C_WRITE_STOP
event independent of whether the I2C address is ACK'd or NACK'd.
In EZ mode, the event is detected only on I2C write transfers that have
EZ data written to the memory structure (an I2C write transfer that only
communicates an I2C address and EZ address, will not result in this event
being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave
(address matching is performed). Set to '1', when STOP or REPEATED START
event is detected. The REPEATED START event is included in this interrupt
cause such that the I2C transfers separated by a REPEATED START can be
distinguished and potentially treated separately by the Firmware. Note
that the second I2C transfer (after a REPEATED START) may be to a different
slave address.
The event is detected on any I2C transfer intended for this slave. Note
that a I2C address intended for the slave (address is matching) will result
in a I2C_STOP event independent of whether the I2C address is ACK'd or
NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event
is detected.
In the case of externally clocked address matching (CTRL.EC_AM_MODE is
'1') AND clock stretching is performed (till the internally clocked logic
takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT
set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH
and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received
address (including the R/W bit) is available in the RX FIFO. In the case
of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally
clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the
event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received
address 0x00 (including the R/W bit) is available in the RX FIFO.   In
the case of externally clocked address matching (CTRL.EC_AM_MODE is '1')
and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field
is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition).
This should not occur, it represents erroneous I2C bus behavior. In case
of a bus error, the I2C slave state machine abort the ongoing transfer.
The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware
may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request register.
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF44</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask register.</description>
          <addressOffset>0xF48</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_S_MASKED != 0.</description>
          <addressOffset>0xF4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).</description>
          <addressOffset>0xF80</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.
Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE:
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.
Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.
Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.
Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready
to transfer data and EMPTY is '1'.
Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access),
due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY
is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode.
Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring
all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is
detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same
as the value observed on the RX line. This condition event is usefull
when transmitter and receiver share a TX/RX line. This is the case in
LIN or SmartCard modes. Set to '1', when event is detected. Write with
'1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request register
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF84</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask register.</description>
          <addressOffset>0xF88</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_TX_MASKED != 0.</description>
          <addressOffset>0xF8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).</description>
          <addressOffset>0xFC0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL
in SCB_RX_FIFO_CTL.
Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.
Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO
is full. Dependent on CTRL.BYTE_MODET:
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.
Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is
set when a data frame is received and the RX FIFO is full, independent
of whether it is ACK'd or NACK'd.
Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.
Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses),
due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY
is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected.
Write with '1' to clear bit. This can be either a start or stop bit(s)
error:
Start bit error: after the detection of the beginning of a start bit period
(RX line changes from '1' to '0'), the middle of the start bit period
is sampled erroneously (RX line is '1').  Note: a start bit error is detected
BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected.
Note: a stop bit error may result in failure to receive successive data
frame(s). Note: a stop bit error is detected AFTER a data frame is received.
A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR
field specifies whether the received frame is dropped or send to the RX
FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame
is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data
frame is send to the RX FIFO. Note that Firmware can only identify the
erroneous data frame in the RX FIFO if it is fast enough to read the data
frame before the hardware writes a next data frame into the RX FIFO; i.e.
the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected.
Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1',
the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is
'0', the received frame is send to the RX FIFO. In SmartCard submode,
negatively acknowledged data frames generate a parity error. Note that
Firmware can only identify the erroneous data frame in the RX FIFO if
it is fast enough to read the data frame before the hardware writes a
next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER
value to set the right IP clock (from the programmable clock IP) to guarantee
successful receipt of the first LIN data frame (Protected Identifier Field)
after the synchronization byte. Set to '1', when event is detected. Write
with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH
+ 1 bit period. Can occur at any time to address unanticipated break fields;
i.e. "break-in-data" is supported. This feature is supported for the UART
standard and LIN submodes. For the UART standard submodes, ongoing receipt
of data frames is NOT affected; i.e. Firmware is ecpected to take the
proper action. For the LIN submode, possible ongoing receipt of a data
frame is stopped and the (partially) received data frame is dropped and
baud rate detection is started. Set to '1', when event is detected. Write
with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request register.
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xFC4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask register.</description>
          <addressOffset>0xFC8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_RX_MASKED != 0.</description>
          <addressOffset>0xFCC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40060000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SCB1</name>
        <value>7</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x0300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>Serial interface bit period oversampling factor expressed in lP clock
cycles. Used for SPI and UART functionality. OVS + 1 IP clock cycles constitute
a single serial interface clock/bit cycle. The IP clock is provided by
the programmable clock IP. This field is NOT used in externally clocked
mode. If OVS is odd, the oversampling factor is even and the first and
second phase of the interface clock period are the same. If OVS is even,
the oversampling factor is odd and the first phase of the interface clock
period is 1 peripheral clock cycle longer than the second phase of the
interface clock period.
In SPI master mode, the valid range is [3, 15]. At an IP frequency of
48 MHz, the maximum IP bit rate is 12 Mbps. The effective system bit rate
is dependent on the external SPI slave that we communicate with. If the
SPI output clock "spi_clk_out" to SPI MISO input "spi_miso_in" round trip
delay is introducing significant delays (multiple "spi_clk_out" cycles),
it may be necessary to increase OVS and/or to set SPI_CTRL.LATE_MISO_SAMPLE
to '1' to achieve the maximum possible system bit rate. The maximum IP
bit rate of 12 Mbps provides an IP centric perspective, assuming ideal
(0 ns) IO cell and routing (chip and board) delay. The required IP clock/IF
clock ratio increases and the calculated maximum bit rate decreases, when
realistic chip and routing delays are taken into account.
In SPI slave mode, the OVS field is NOT used. However, there is a frequency
requirement for the IP clock wrt. the interface (IF) clock to guarantee
functional correct behavior. This requirement is expressed as a ratio:
IP clock/IF clock. The ratio is dependent on the setting of RX_CTRL.MEDIAN
and the external SPI master's capability to support "late MISO sample"
functionality (similar to our SPI master functionality represented by
SPI_CTRL.LATE_MISO_SAMPLE):
- MEDIAN is '0' and external SPI master has NO "late MISO sample functionality":
IP clock/IF clock >= 6. At a IP frequency of 48 MHz,  the maximum bit
rate is 8 Mbps.
- MEDIAN is '0' and external SPI master has "late MISO sample functionality":
IP clock/IF clock >= 3. At a IP frequency of 48 MHz,  the maximum bit
rate is 16 Mbps.
- MEDIAN is '1' and external SPI master has NO "late MISO sample functionality":
IP clock/IF clock >= 8. At a IP frequency of 48 MHz,  the maximum bit
rate is 6 Mbps.
- MEDIAN is '1' and external SPI master has "late MISO sample functionality":
IP clock/IF clock >= 4. At a IP frequency of 48 MHz,  the maximum bit
rate is 12 Mbps.
The maximum bit rates provide an IP centric perspective, assuming ideal
(0 ns) IO cell and routing (chip and board) delay. The required IP clock/IF
clock ratio increases and the calculated maximum bit rate decreases, when
realistic chip and routing delays are taken into account.
In UART standard submode (including LIN), the valid range is [7, 15].
In UART SmartCard submode, the valid range is [7, 15].
In UART TX IrDA submode this field indirectly specifies the oversampling.
The oversampling determines the interface clock/bit cycle and the width
of the pulse.  Only normal transmission mode is supported, the pulse is
roughly 3/16 of the bit period (for all bit rates). There is only one
valid OVS value:
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
           IP clock frequency of 16*57.6 KHz for 57.6 Kbps.
           IP clock frequency of 16*38.4 KHz for 38.4 Kbps.
           IP clock frequency of 16*19.2 KHz for 19.2 Kbps.
           IP clock frequency of 16*9.6 KHz for 9.6 Kbps.
           IP clock frequency of 16*2.4 KHz for 2.4 Kbps.
           IP clock frequency of 16*1.2 KHz for 1.2 Kbps.
- all other values are not used in normal mode.
In UART RX IrDA submode (1.2, 2.4, 9.6, 19.2, 38.4, 57.6 and 115.2 Kbps)
this field indirectly specifies the oversampling. The oversampling determines
the interface clock/bit cycle and the width of the pulse. In normal transmission
mode, this pulse is roughly 3/16 of the bit period (for all bit rates).
In low power transmission mode, this pulse is potentially smaller (down
to 1.62 us typical and 1.41 us minimal) than 3/16 of the bit period (for
&lt; 115.2 Kbps bitrates). Pulse widths greater or equal than two IP clock
cycles are guaranteed to be detected by the receiver. Pulse widths less
than two IP clock cycles and greater or equal than one IP clock cycle
may be detected by the receiver. Pulse widths less than one IP clock cycle
will not be detected by the receiver. RX_CTRL.MEDIAN should be set to
'1' for IrDA receiver functionality. The IP clock (as provided by the
programmable clock IP) and the oversampling together determine the IrDA
bitrate. Normal mode, OVS field values (with the required IP clock frequency):
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
           IP clock frequency of 16*57.6 KHz for 57.6 Kbps.
           IP clock frequency of 16*38.4 KHz for 38.4 Kbps.
           IP clock frequency of 16*19.2 KHz for 19.2 Kbps.
           IP clock frequency of 16*9.6 KHz for 9.6 Kbps.
           IP clock frequency of 16*2.4 KHz for 2.4 Kbps.
           IP clock frequency of 16*1.2 KHz for 1.2 Kbps.
- all other values are not used in normal mode.
Low power mode, OVS field values (with the required IP clock frequency):
- 0: 16 times oversampling.
           IP clock frequency of 16*115.2 KHz for 115.2 Kbps.
- 1: 32 times oversampling.
           IP clock frequency of 32*57.6 KHz for 57.6 Kbps.
- 2: 48 times oversampling.
           IP clock frequency of 48*38.4 KHz for 38.4 Kbps.
- 3: 96 times oversampling.
           IP clock frequency of 96*19.2 KHz for 19.2 Kbps.
- 4: 192 times oversampling.
           IP clock frequency of 192*9.6 KHz for 9.6 Kbps.
- 5: 768 times oversampling.
           IP clock frequency of 768*2.4 KHz for 2.4 Kbps.
- 6: 1536 times oversampling.
           IP clock frequency of 1536*1.2 KHz for 1.2 Kbps.
- all other values are not used in low power mode.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address
matching (I2C) or selection (SPI). In internally clocked mode, the serial
interface protocols run off the peripheral clock. In externally clocked
mode, the serial interface protocols run off the clock as provided by
the serial interface. Externally clocked mode is only used for synchronous
serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only
Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation.
In internally clocked mode, the serial interface protocols run off the
peripheral clock. In externally clocked mode, the serial interface protocols
run off the clock as provided by the serial interface. Externally clocked
operation mode is only used for synchronous serial interface protocols
(SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode
(all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave,
EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP
will degrade the effective bitrate).
In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied
to the serial interface protocol. This meta protocol adds meaning to the
data frames transferred by the serial interface protocol: a data frame
can represent a memory address, a write memory data element or a read
memory data element. EZ mode is only used for synchronous serial interface
protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola
modes: 0, 1, 2, 3) is supported and the transmitter should use continuous
data frames; i.e. data frames mot seperated by slave deselection. This
mode is only applicable to slave functionality. In EZ mode, the slave
can read from and write to an addressable memory structure of 32 bytes.
In EZ mode, data frames should 8-bit in size and should be transmitted
and received with the Most Significant Bit (MSB) first.
In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries,
but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to
be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO
('1') or not ('0').
In I2C mode, this field is used to allow the slave to put the received
slave address or general call address in the RX FIFO. Note that a received
matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both
I2C read and write transfers.
In multi-processor UART receiver mode, this field is used to allow the
receiver to put the received address in the RX FIFO. Note: non-matching
addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic
and the MMIO SW accesses to EZ memory coincide/collide, this bit determines
whether a SW access should block and result in bus wait states ('BLOCK
is 1') or not (BLOCK is '0'). IF BLOCK is �0� and the accesses collide,
MMIO read operations return 0xffff:ffff and MMIO write operations are
ignored. Colliding accesses are registered as interrupt causes: field
BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Mode of operation (3: Reserved)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize
the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and
UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of
a submode, master/slave functionality and transmitter/receiver functionality
when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information.
This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL)
information.
- Program CTRL to enable IP, select the specific operation mode and oversampling
factor.
When the IP is enabled, no control information should be changed. Changes
should be made AFTER disabling the IP, e.g. to modify the operation mode
(from I2C to SPI) or to go from externally to internally clocked. The
change takes effect after the IP is re-enabled. Note that disabling the
IP will cause re-initialization of the design and associated state is
lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory (this is only possible in EZ mode). This bit can be used
by SW to determine whether it is safe to issue a SW access to the EZ memory
(without bus wait states (a blocked SW access) or bus errors being generated).
Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are
used to indicate whether a SW access was actually blocked by externally
clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control register.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001F001F</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C
CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode
read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR
is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified
during ongoing bus transfers.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C
CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode
write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR
is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified
during ongoing bus transfers.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status register.
The register fields reflect register states without a default/reset value
(CURR_RD_ADDR and CURR_WR_ADDR) or reflect an external bus state. Therefore,
these registers are undefined after the IP is enabled.</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field
after a read access to the memory buffer. However, when the last memory
buffer address is reached, the address is NOT incremented (but remains
at the maximim memory buffer address).
The field is used to determine how many bytes have been read (# bytes
= CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR).
This field is reliable during when there is no bus transfer. This field
is potentially unreliable when there is a bus transfer bus transfer: when
CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field
after a read access to the memory buffer. However, when the last memory
buffer address is reached, the address is NOT incremented (but remains
at the maximim memory buffer address).
The field is used to determine how many bytes have been written (# bytes
= CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
This field is reliable during when there is no bus transfer. This field
is potentially unreliable when there is a bus transfer bus transfer: when
CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transferr.
For SPI, the field is '1' when the slave is selected.
For I2C, the field is set to '1' at a I2C START/RESTART. In case of an
address match, the  field is set to '0' on a I2C STOP. In case of NO address
match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register
are reliable (CMD_RESP_EC_BUSY is '0') or not reliable (CMD_RESP_EC_BUSY
is '1'). Note:
- When there is no bus transfer, CMD_RESP_EC_BUSY is '0'.
- When there is a bus transfer, CMD_RESP_EC_BUSY is '0', when the CURR_RD_ADDR
and CURR_WR_ADDR are not updated by the HW.
- When there is a bus transfer, CMD_RESP_EC_BUSY is '1', when the CURR_RD_ADDR
or CURR_WR_ADDR are updated by the HW. Note that this update lasts a single
serial interface clock cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control register.</description>
          <addressOffset>0x20</addressOffset>
          <resetValue>0x03000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is
used in master mode. In slave mode, both continuous and non-continuous
SPI data transfers are supported independent of this field.
When continuous transfers are enabled individual data frame transfers
are not necessarily seperated by slave deselection (as indicated by the
level or pulse on the SELECT line): if the TX FIFO has multiple data frames,
data frames are send out without slave deselection.
When continuous transfers are not enabled individual data frame transfers
are always seperated by slave deselection: independent of the availability
of TX FIFO data frames, data+G65 frames are send out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.
When '1', the data frame start indication is a pulse on the SELECT line
that precedes the transfer of the first data frame bit.
When '0', the data frame start indication is a pulse on the SELECT line
that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock phase. This
field, together with the CPOL field, indicates when MOSI data is driven
and MISO data is captured:
- Motorola mode 0. CPOL is �0�, CPHA is �0�: MOSI  is driven on a falling
edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is �0�, CPHA is �1�: MOSI  is driven on a rising
edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is �1�, CPHA is �0�: MOSI  is driven on a rising
edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is �1�, CPHA is �1�: MOSI  is driven on a falling
edge of SCLK. MISO is captured on a rising edge of SCLK.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. Only used in SPI Motorola submode. This
field, together with the CPHA field, indicates when MOSI data is driven
and MISO data is captured:
- CPOL is �0�: SCLK is �0� when not transmitting data.
- CPOL is �1�: SCLK is �1� when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
When '0', the default applies (for Motorola as determined by CPOL and
CPHA, for Texas Instruments on the falling edge of SCLK and for National
Semiconductors on the rising edge of SCLK).
When '1', the alternate clock edge is used (which comes half a SPI SCLK
period later). Late sampling addresses the round trip delay associated
with transmitting SCLK from the master to the slave and transmitting MISO
from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode.
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful
for slave devices that use SCLK for functional operation other than just
SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave
select signal 0 (master mode) and to the incoming SPI slave select signal
(slave mode). For Motorola and National Semiconductors submodes:
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Istruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity. SSEL_POLARITY1 applies to the outgoing SPI slave
select signal 1 (master mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity. SSEL_POLARITY2 applies to the outgoing SPI slave
select signal 2 (master mode).</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity. SSEL_POLARITY3 applies to the outgoing SPI slave
select signal 3 (master mode).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line "spi_miso_in" is connected to the SPI MISO
pin.
'1': the SPI master MISO line "spi_miso_in" is connected to the SPI master
MOSI line "spi_mosi_out". In other words, in loopback mode the SPI master
receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of SPI operation (3: Reserved).</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four outgoing SPI slave select signals:
- 0: Slave 0, SPI_SELECT[0].
- 1: Slave 1, SPI_SELECT[1].
- 2: Slave 2, SPI_SELECT[2].
- 3: Slave 3, SPI_SELECT[3].
Only used in master mode. The IP should be disabled when changes are made
to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence
on availability of data frames in the TX FIFO. In slave mode, when selected
and there is no data frame in the TX FIFO, the slave will transmit all
'1's. In both master and slave modes, received data frames will be lost
if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status register.</description>
          <addressOffset>0x24</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction.
For Motorola and National submodes, the busy bit is '1', when the slave
selection (low active) is activated. For TI submode, the busy bit is '1'
from the time the preceding/coinciding slave select (high active) is activated
for the first transmitted data frame, till the last MOSI/MISO bit of the
last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible
in EZ mode). This bit can be used by SW to determine whether BASE_ADDR
and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable
in internally clocked mode. In externally clocked mode the field may be
unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock
domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This
field is only reliable in internally clocked mode. In externally clocked
mode the field may be unreliable, as clock domain synchronization is not
performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control register.</description>
          <addressOffset>0x40</addressOffset>
          <resetValue>0x03000000</resetValue>
          <resetMask>0x03010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
When '0', the transmitter TX line "uart_tx_out" is connected to the TX
pin and the receiver RX line "uart_rx_in" is connected to the RX pin.
When '1', the transmitter TX line "uart_tx_out" is connected to the receiver
RX line "uart_rx_in". A similar connections scheme is followed for "uart_rts_out"
and "uart_cts_in".
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Submode of UART operation (3: Reserved)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control register.</description>
          <addressOffset>0x44</addressOffset>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x00000137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of
halve bit periods. Valid range is [1, 7]; i.e. a stop period should last
at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1',
the transmitter generates an odd parity. Only applicable in standard UART
and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard
UART submodes. In SmartCard submode, parity generation is always enabled
through hardware. In IrDA submode, parity generation is always disabled
through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement
is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control register.</description>
          <addressOffset>0x48</addressOffset>
          <resetValue>0x000A0002</resetValue>
          <resetMask>0x000F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of
halve bit periods. Valid range is [1, 7]; i.e. a stop period should last
at least one bit period. If STOP_BITS is '1', stop bits error detection
is NOT performed. If STOP_BITS is in [2, 7], stop bits error detection
is performed and the associated interrupt cause INTR_RX.FRAME_ERROR is
set to '1' if an error is detected. In other words, the receiver supports
data frames with a 1 bit period stop bit sequence, but requires at least
1.5 bit period stop bit sequences to detect errors. This limitation is
due to possible transmitter and receiver clock skew that prevents the
design from doing reliable stop bit detection for short (1 bit bit period)
stop bit sequences. Note that in case of a stop bits error, the successive
data frames may get lost as the receiver needs to resynchronize its start
bit detection. The amount of lost data frames depends on both the amount
of stop bits, the idle ('1') time between data frames and the data frame
value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the
receiver expects an odd parity. Only applicable in standard UART and SmartCard
submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard
UART submode. In SmartCard submode, parity checking is always enabled
through hardware. In IrDA submode, parity checking is always disabled
through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal "uart_rx_in". Inversion is after local
loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to
the RX FIFO. When '1', received data is dropped and lost. Only applicable
in standard UART and SmartCard submodes (negatively acknowledged SmartCard
data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0',
received data is send to the RX FIFO. When '1', received data is dropped
and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this
mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor
mode, the 9th received bit of a data frame seperates addresses (bit is
'1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA
and RX_MATCH.MASK. In the case of a match, subsequent received data are
sent to the RX FIFO. In the case of NO match, subsequent received data
are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs
break detection and baud rate detection on the incoming data. First, break
detection counts the amount of bit periods that have a line value of '0'.
BREAK_WIDTH specifies the minum required amount of bit periods. Successful
break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'.
Second, baud rate detection counts the amount of peripheral clock periods
that are use to receive the synchronization byte (0x55; least significant
bit first). The count is available through UART_RX_STATUS.BR_COUNTER.
Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt
cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine
the receiver clock to the transmitter clock. The receiver software can
use the BR_COUNTER value to set the right IP clock (from the programmable
clock IP) to guarantee successful receipt of the first LIN data frame
(Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips
start bit detection for the first received data frame. Instead, it synchronizes
on the first received data frame bit, which should be a '1'. This functionality
is intended for wake up from DeepSleep when receiving a data frame. The
transition from idle ('1') to START ('0') on the RX line is used to wake
up the CPU. The transition detection (and the associated wake up functionality)
is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART
receiver functionality. Once enabled, it is assumed that the START bit
is ongoing (the CPU wakeup and SCB enable time should be less than the
START bit period). The SCB will synchronize to a '0' to '1' transition,
which indicates the first data frame bit is received (first data frame
bit should be '1'). After synchronization to the first data frame bit,
the SCB will resume normal UART functionality: subsequent data frames
will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a
break. During a break the transmitted/received line value is '0'. This
feature is useful for standard UART submode and LIN submode ("break field"
detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit
is set to '1'. Note that break detection precedes baud rate detection,
which is used to synchronize/refine the receiver clock to the transmitter
clock. As a result, break detection operates with an unsynchronized/unrefined
receiver clock. Therefore, the receiver's definition of a bit period is
imprecise and the setting of this field should take this imprecision into
account. The LIN standard also accounts for this imprecision: a LIN start
bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods
during regular transmission, whereas the LIN break detection should be
at least 13 consecutive '0' bit periods. This provides for a margin of
4 bit periods. Therefore, the default value of this field is set to 10,
representing a minimal break field with of 10+1 = 11 bit periods; a value
in between the 9 consecutive bit periods of a regular transmission and
the 13 consecutive bit periods of a break field. This provides for slight
imprecisions of the receiver clock wrt. the transmitter clock. There should
not be a need to program this field to any value other than its default
value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status register.</description>
          <addressOffset>0x4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of
a 0x55 data frame (sent least signficant bit first) as determined by the
receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that
constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT
is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control register
UART flow control is a design time configuration parameter, which make
the presence of this MMIO register conditional to the configuration. The
"uart_rts_out" and "uart_cts_in" are always present on the IP interface.
If flow control is configured out, "uart_rts_out" is NOT connected, and
"uart_cts_in" should be connected to '0'.</description>
          <addressOffset>0x50</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0301000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount
of this field, a Ready To Send (RTS) output signal "uart_rts_out" is activated.
By setting this field to "0", flow control is effectively SW disabled
(may be useful for debug purposes).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal "uart_rts_out":
'0': RTS is low/'0' active; "uart_rts_out" is '0' when active and "uart_rts_out"
is '1' when inactive.
'1': RTS is high/'1' active; "uart_rts_out" is '1' when active and "uart_rts_out"
is '0' when inactive.
During IP reset (Hibernate system power mode), "uart_rts_out" is '1'.
This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal "uart_cts_in":
'0': CTS is low/'0' active; "uart_cts_in" is '0' when active and "uart_cts_in"
is '1' when inactive.
'1': CTS is high/'1' active; "uart_cts_in" is '1' when active and "uart_cts_in"
is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal "uart_cts_in" by the UART transmitter:
'0': Disabled. The UART transmitter ignores "uart_cts_in", and transmits
when a data frame is available for transmission in the TX FIFO or the
TX shift register.
'1': Enabled. The UART transmitter uses "uart_cts_in" to qualify the transmission
of data. It transmits when "uart_cts_in" is active and a data frame is
available for transmission in the TX FIFO or the TX shift register.
If UART_CTRL.LOOPBACK is '1', "uart_cts_in" is connected to "uart_rts_out"
in the IP (both signals are subjected to signal polarity changes are indicated
by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control register.</description>
          <addressOffset>0x60</addressOffset>
          <resetValue>0x0000FB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS +
1 peripheral clock periods constitute the high phase of a bit period.
The valid range is [5, 15] with input signal median filtering and [4,
15] without input signal median filtering.
The field is only used in master mode. In slave mode, the field is NOT
used. However, there is a frequency requirement for the IP clock wrt.
the regular interface (IF) high time to guarantee functional correct behavior.
With input signal median filtering, the IF high time should be >= 6 IP
clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering,
the IF high time should be >= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1
peripheral clock periods constitute the low phase of a bit period. The
valid range is [7, 15] with input signal median filtering and [6, 15]
without input signal median filtering.
The field is only used in master mode. In slave mode, the field is NOT
used. However, there is a frequency requirement for the IP clock wrt.
the regular (no stretching) interface (IF) low time to guarantee functional
correct behavior. With input signal median filtering, the IF low time
should be >= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input
signal median filtering, the IF low time should be >= 7 IP clock cycles
and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when
the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd
when the receiver FIFO is full. When '0', clock stretching is used instead
(till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd
(no ACK or clock stretching) and treated as a non matching slave address.
This is useful for slaves that do not need any data supplied within the
general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when
the receiver FIFO is not full. In EZ mode, this field should be set to
'1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when
the receiver FIFO is not full. In EZ mode, this field should be set to
'1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address
match or general call address (and S_GENERAL_IGNORE is '0'). Only used
when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the
receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer
full).
For externally clocked logic (EC_AM is '1') on an address match or general
call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when
EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately
NACK'd. There are two possibilities: 1). the internally clocked logic
is enabled (we are in Active system power mode) and it handles the rest
of the current transfer. In this case the I2C master will not observe
the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep
system power mode). In this case the I2C master will observe the NACK
and may retry the transfer in the future (which gives the internally clocked
logic the time to wake up from DeepSleep system power mode).
- 0: clock stretching is performed (till the internally clocked logic
takes over). The internally clocked logic will handle the ongoing transfer
as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when
the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer
full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines
are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines
are routed internally in the peripheral, and as a result unaffected by
other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave
modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status register.</description>
          <addressOffset>0x64</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000031</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START
is detected or from the time the SCL line is '0'. The bus is considered
idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY
is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect
a busy bus. This time is the maximum high time of the SCL line. For a
100 kHz interface frequency, this maximum high time may last roughly 5
us (half a bit period).
For single master systems, BUS_BUSY does not have to be used to detect
an idle bus before a master starts a transfer using I2C_M_CMD.M_START
(no bus collisions).
For multi-master systems, BUS_BUSY can be used to detect an idle bus before
a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent
bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing
the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible
in EZ mode). This bit can be used by SW to determine whether BASE_ADDR
and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When
the I2C slave is inactive/idle or receiving START, REPEATED START, STOP
or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When
the I2C master is inactive/idle or transmitting START, REPEATED START,
STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only
reliable in internally clocked mode. In externally clocked mode the field
may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'),
as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer.
This field is only reliable in internally clocked mode. In externally
clocked mode the field may be unreliable, as clock domain synchronization
is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode.</description>
          <addressOffset>0x68</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED
START is transmitted depends on the state of the master state machine.
A START is only transmitted when the master state machine is in the default
state. A REPEATED START is transmitted when the master state machine is
not in the default state, but is working on an ongoing transaction. The
REPEATED START can only be transmitted after a NACK or ACK has been received
for a transmitted data element or after a NACK has been transmitted for
a received data element. When this action is performed, the hardware sets
this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY
is '0', note that BUSY has a default value of '0'). For bus idle detection
the hardware relies on STOP detection. As a result, bus idle detection
is only functional after at least one I2C bus transfer has been detected
on the bus (default/reset value of BUSY is '0') . A START is only transmitted
when the master state machine is in the default state. When this action
is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action
is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When
this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the
hardware sets this field to '0'. This command has a higher priority than
I2C_M_CMD.M_START: in situations where both a STOP and a REPEATED START
could be transmitted, M_STOP takes precedence over M_START.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode.</description>
          <addressOffset>0x6C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action
is performed, the hardware sets this field to '0'. In EZ mode, this field
should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When
this action is performed, the hardware sets this field to '0'.  In EZ
mode, this field should be set to '0' (it is only to be used in non EZ
mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK
or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration register.
The filters are used to remove glitches and to guarantee I2C compliant
SCL and SDA setup and hold times. The filters are trimmable.</description>
          <addressOffset>0x70</addressOffset>
          <resetValue>0x002A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for "i2c_sda_in" 50 ns filter. See s8i2cs BROS (001-59539) for
more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of "i2c_sda_in" filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for "i2c_scl_in" 50 ns filter. See s8i2cs BROS (001-59539) for
more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of "i2c_scl_in" filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 0. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 1. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for "i2c_sda_out" 50 ns filter 2. See s8i2cs BROS (001-59539)
for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative "i2c_sda_out" filter delay:
"0": 0 ns.
"1": 50 ns (filter 0 enabled).
"2": 100 ns (filters 0 and 1 enabled).
"3": 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control register.</description>
          <addressOffset>0x200</addressOffset>
          <resetValue>0x00000107</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted
data frame. This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8]. For SPI, the valid range is
[3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1').
For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register.</description>
          <addressOffset>0x204</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number
of this field, a transmitter trigger event is generated.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated.
Invalidation will last for as long as this field is '1'. If a quick clear/invalidation
is required, the field should be set to '1' and be followed by a set to
'0'. If a clear/invalidation is required for an extended time period,
the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO
entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register.
This register is not used in EZ and CMD_RESP modes.</description>
          <addressOffset>0x208</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F801F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the transmitter FIFO. The value of this field ranges
from 0 to FF_DATA_NR.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1')
or not ('0'). The shift register can be considered the top of the TX FIFO
(the data frame is not included in the USED field of the TX FIFO). The
shift register is a working register and holds the data frame that is
currently transmitted (when the protocol state machine is transmitting
a data frame) or the data frame that is tranmitted next (when the protocol
state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the
hardware.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write register.
When the IP is disabled (CTRL.ENABLED is '0') or when the TX FIFO is full,
a write to this register is dropped. This register should only be used
in FIFO mode (and not in EZ or CMD_RESP modes). This register is "write
only"; a read from this register returns "0".</description>
          <addressOffset>0x240</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that
of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0]
are used.
A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control register.</description>
          <addressOffset>0x300</addressOffset>
          <resetValue>0x00000107</resetValue>
          <resetMask>0x0000030F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received
data frame. This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8]. For SPI, the valid range is
[3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and
I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1').
For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on
input interface lines. This filter should reduce the susceptability to
errors. However, its requires higher oversampling values. For UART IrDA
submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register.</description>
          <addressOffset>0x304</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number
of this field, a receiver trigger event is generated.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated.
Invalidation will last for as long as this field is '1'. If a quick clear/invalidation
is required, the field should be set to '1' and be followed by a set to
'0'. If a clear/invalidation is required for an extended time period,
the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze
will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status register.
This register is not used in EZ and CMD_RESP modes.</description>
          <addressOffset>0x308</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F801F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the receiver FIFO. The value of this field ranges
from 0 to FF_DATA_NR.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data
frame ('1') or not ('0'). The shift register can be considered the bottom
of the RX FIFO (the data frame is not included in the USED field of the
RX FIFO). The shift register is a working register and holds the data
frame that is currently being received (when the protocol state machine
is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written
by the hardware.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask register.</description>
          <addressOffset>0x310</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.
In UART multi-processor mode, all 8 bits are used.
In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization
of the first transmitted byte in a I2C transfer: the first 7 bits represent
the address of the addressed slave, and the last 1 bit is a read/write
indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of
the ADDR field bits in the ADDR field take part in the matching of the
slave address: MATCH = ((ADDR &amp; MASK) == ("slave address" &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read register.
When the IP is disabled (CTRL.ENABLED is '0') or when the RX FIFO is empty,
a read from this register returns 0xffff:ffff. This register should only
be used in FIFO mode (and not in EZ or CMD_RESP modes). This register
is "read only"; a write to this register is ignored.</description>
          <addressOffset>0x340</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the
data frame from the FIFO; i.e. behavior is similar to that of a POP operation.
Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
This register has a side effect when read by software: a data frame is
removed from the FIFO. This may be undesirable during debug; i.e. a read
during debug should NOT have a side effect. To this end, the IP uses the
AHB-Lite "hmaster[0]" input signal. When this signal is '1' in the address
cycle of a bus transfer, a read transfer will not have a side effect.
As a result, a read from this register will not remove a data frame from
the FIFO. As a result, a read from this register behaves as a read from
the SCB_RX_FIFO_RD_SILENT register.
A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read register.
When the IP is disabled (CTRL.ENABLED is '0') or when the RX FIFO is empty,
a read from this register returns 0xffff:ffff. This register should only
be used in FIFO mode (and not in EZ or CMD_RESP modes).</description>
          <addressOffset>0x344</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove
the data frame from the FIFO; i.e. behavior is similar to that of a PEEK
operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA0</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x400</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA1</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x404</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA2</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x408</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA3</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x40C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA4</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x410</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA5</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x414</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA6</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x418</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA7</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x41C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA8</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x420</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA9</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x424</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA10</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x428</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA11</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x42C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA12</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x430</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA13</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x434</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA14</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x438</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA15</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x43C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA16</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x440</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA17</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x444</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA18</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x448</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA19</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x44C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA20</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x450</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA21</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x454</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA22</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x458</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA23</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x45C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA24</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x460</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA25</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x464</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA26</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x468</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA27</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x46C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA28</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x470</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA29</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x474</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA30</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x478</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EZ_DATA31</name>
          <description>Memory buffer registers.
When the IP is disabled (CTRL.ENABLED is '0'), a read from these registers
return 0xffff:ffff. It is under MMIO register control whether accesses
to this register should introduce bus wait states or be discarded when
the externally clocked logic is accessing the memory structure. These
registers should only be used in EZ and CMD_RESP modes (and not in FIFO
mode).</description>
          <addressOffset>0x47C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>EZ_DATA</name>
              <description>Data in buffer memory location. In case of a blocked discarded access,
a read access returns 0xffff:ffff and a write access is dropped. Note
that the 0xffff:ffff value is unique (not a legal EZ_DATA byte value)
and can be detected by SW. Note that a discarded write access can be detected
by reading back the written value.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal register
Enables software to determine the source of the combined interrupt output
signals "interrupt_ic", "interrupt_ec" and "interrupt".</description>
          <addressOffset>0xE00</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ("interrupt_master"): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ("interrupt_slave"): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ("interrupt_tx"): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ("interrupt_rx"): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ("interrupt_i2c_ec"): INTR_I2C_EC_MASKED
!= 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ("interrupt_spi_ec"): INTR_SPI_EC_MASKED
!= 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register
The fields in this register are set by HW and are cleared by software
by writing a '1'.  These interrupt causes are generated by externally
clocked logic. HW clears the interrupt causes to '0', when the IP is disabled.</description>
          <addressOffset>0xE80</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).
Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of
a write transfer (I2C STOP). This event is an indication that a buffer
memory location has been written to. For EZ mode: a  transfer that only
writes the base address does NOT activate this event.
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of
a read transfer (I2C STOP). This event is an indication that a buffer
memory location has been read from.
Only available for a slave request with an address match, in EZ and CMD_RESP
modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0xE88</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_I2C_EC_MASKED != 0.</description>
          <addressOffset>0xE8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register
The fields in this register are set by HW and are cleared by software
by writing a '1'. These interrupt causes are generated by externally clocked
logic. HW clears the interrupt causes to '0', when the IP is disabled.</description>
          <addressOffset>0xEC0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked
selection is '1'.
Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of
a write transfer (SPI deselection). This event is an indication that a
buffer memory location has been written to. For EZ mode: a  transfer that
only writes the base address does NOT activate this event.
Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of
a read transfer (SPI deselection). This event is an indication that a
buffer memory location has been read from.
Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0xEC8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_SPI_EC_MASKED != 0.</description>
          <addressOffset>0xECC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).
The interrupt causes should only be used for internally clocked operation;
i.e. EC_OP is '0'.</description>
          <addressOffset>0xF00</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA
line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives
a NACK (typically after the master transmitted the slave address or TX
data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK
(typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are
sent and the transmit FIFO is empty.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request register
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF04</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask register.</description>
          <addressOffset>0xF08</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_M_MASKED != 0.</description>
          <addressOffset>0xF0C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).
The interrupt causes should only be used for internally clocked operation;
i.e. EC_OP is '0'.</description>
          <addressOffset>0xF40</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the
same as the value observed on the SDA line (while the SCL line is '1').
This should not occur, it represents erroneous I2C bus behavior. In case
of lost arbitration, the I2C slave state machine abort the ongoing transfer.
The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave
receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives
a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address
matching is performed). Set to '1', when STOP or REPEATED START event
is detected. The REPEATED START event is included in this interrupt cause
such that the I2C transfers separated by a REPEATED START can be distinguished
and potentially treated separately by the Firmware. Note that the second
I2C transfer (after a REPEATED START) may be to a different slave address.
In non EZ mode, the event is detected on any I2C write transfer intended
for this slave. Note that a I2C write address intended for the slave (address
is matching and a it is a write transfer) will result in a I2C_WRITE_STOP
event independent of whether the I2C address is ACK'd or NACK'd.
In EZ mode, the event is detected only on I2C write transfers that have
EZ data written to the memory structure (an I2C write transfer that only
communicates an I2C address and EZ address, will not result in this event
being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave
(address matching is performed). Set to '1', when STOP or REPEATED START
event is detected. The REPEATED START event is included in this interrupt
cause such that the I2C transfers separated by a REPEATED START can be
distinguished and potentially treated separately by the Firmware. Note
that the second I2C transfer (after a REPEATED START) may be to a different
slave address.
The event is detected on any I2C transfer intended for this slave. Note
that a I2C address intended for the slave (address is matching) will result
in a I2C_STOP event independent of whether the I2C address is ACK'd or
NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event
is detected.
In the case of externally clocked address matching (CTRL.EC_AM_MODE is
'1') AND clock stretching is performed (till the internally clocked logic
takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT
set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH
and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received
address (including the R/W bit) is available in the RX FIFO. In the case
of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally
clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the
event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received
address 0x00 (including the R/W bit) is available in the RX FIFO.   In
the case of externally clocked address matching (CTRL.EC_AM_MODE is '1')
and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field
is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition).
This should not occur, it represents erroneous I2C bus behavior. In case
of a bus error, the I2C slave state machine abort the ongoing transfer.
The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware
may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request register.
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF44</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask register.</description>
          <addressOffset>0xF48</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_S_MASKED != 0.</description>
          <addressOffset>0xF4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).</description>
          <addressOffset>0xF80</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.
Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE:
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.
Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.
Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.
Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready
to transfer data and EMPTY is '1'.
Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access),
due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY
is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode.
Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring
all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is
detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same
as the value observed on the RX line. This condition event is usefull
when transmitter and receiver share a TX/RX line. This is the case in
LIN or SmartCard modes. Set to '1', when event is detected. Write with
'1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request register
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xF84</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask register.</description>
          <addressOffset>0xF88</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_TX_MASKED != 0.</description>
          <addressOffset>0xF8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request register.
The register fields are not retained In DeepSleep power mode: HW clears
the interrupt causes to '0', when coming out of DeepSleep power mode.
In addition, HW clears the interrupt causes to '0', when the IP is disabled.
As a result, the interrupt causes are only available in Active/Sleep power
modes; they are generated by internally clocked logic (this logic operates
on a clock that is only available in Active/Sleep power modes).</description>
          <addressOffset>0xFC0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL
in SCB_RX_FIFO_CTL.
Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.
Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO
is full. Dependent on CTRL.BYTE_MODET:
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.
Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is
set when a data frame is received and the RX FIFO is full, independent
of whether it is ACK'd or NACK'd.
Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.
Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses),
due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY
is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected.
Write with '1' to clear bit. This can be either a start or stop bit(s)
error:
Start bit error: after the detection of the beginning of a start bit period
(RX line changes from '1' to '0'), the middle of the start bit period
is sampled erroneously (RX line is '1').  Note: a start bit error is detected
BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected.
Note: a stop bit error may result in failure to receive successive data
frame(s). Note: a stop bit error is detected AFTER a data frame is received.
A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR
field specifies whether the received frame is dropped or send to the RX
FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame
is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data
frame is send to the RX FIFO. Note that Firmware can only identify the
erroneous data frame in the RX FIFO if it is fast enough to read the data
frame before the hardware writes a next data frame into the RX FIFO; i.e.
the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected.
Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1',
the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is
'0', the received frame is send to the RX FIFO. In SmartCard submode,
negatively acknowledged data frames generate a parity error. Note that
Firmware can only identify the erroneous data frame in the RX FIFO if
it is fast enough to read the data frame before the hardware writes a
next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER
value to set the right IP clock (from the programmable clock IP) to guarantee
successful receipt of the first LIN data frame (Protected Identifier Field)
after the synchronization byte. Set to '1', when event is detected. Write
with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH
+ 1 bit period. Can occur at any time to address unanticipated break fields;
i.e. "break-in-data" is supported. This feature is supported for the UART
standard and LIN submodes. For the UART standard submodes, ongoing receipt
of data frames is NOT affected; i.e. Firmware is ecpected to take the
proper action. For the LIN submode, possible ongoing receipt of a data
frame is stopped and the (partially) received data frame is dropped and
baud rate detection is started. Set to '1', when event is detected. Write
with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request register.
When read, this register reflects the interrupt request register.</description>
          <addressOffset>0xFC4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask register.</description>
          <addressOffset>0xFC8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request register
When read, this register reflects a bitwise and between the interrupt
request and mask registers. This register allows SW to read the status
of all mask enabled interrupt causes with a single load operation, rather
than two load operations: one for the interrupt causes and one for the
masks. This simplifies Firmware development. The associated interrupt
is active ('1'), when INTR_RX_MASKED != 0.</description>
          <addressOffset>0xFCC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <baseAddress>0x40070000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TCPWM0</name>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>TCPWM1</name>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>TCPWM2</name>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>TCPWM3</name>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>TCPWM4</name>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>TCPWM5</name>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.
Used to disbale/enable the counters.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0,
TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the
counter is disabled. When a counter is disabled, command and status information
associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ("tr_overflow", "tr_underflow" and "tr_compare_match").
- the counter's line outputs ("line_out" and "line_compl_out").</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.
Enables software controlled counter operation.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F3F</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger
is generated and the HW sets the field to '0' when the SW trigger has
taken effect. It should be noted that the HW operates on the counter frequency.
If the counter is disabled through CTRL.COUNTER_ENABLED, the field is
immediately set to '0'.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.
Enables software to determine the source of the combined interrupt output
signal "interrupt". The register fields are not retained. This is to ensure
that they come up as '0' after coming out of DeepSleep system power mode.</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED,
the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CNT0</name>
          <addressOffset>256</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CNT1</name>
          <addressOffset>320</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CNT2</name>
          <addressOffset>384</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CNT3</name>
          <addressOffset>448</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CNT4</name>
          <addressOffset>512</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CNT5</name>
          <addressOffset>576</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a
function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch
event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field
has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch
event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the "dt_line_out"
and "dt_line_compl_out" signals till the next terminal count event (synchronous
kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the "dt_line_out"
and "dt_line_compl_out" signals when present. In asynchronous kill mode,
STOP_EDGE should be NO_EDGE_DET.
This field has a function in PWM and PWM_DT modes only. This field is
only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.
This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine
the dead time: amount of dead time cycles in the counter clock domain.
In all other modes, the lower 3 bits of this field determine pre-scaling
of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIVBY1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY4</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY8</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY16</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY32</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY64</name>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIVBY128</name>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by
hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert
"dt_line_out" and "dt_line_compl_out".  Inversion is the last step in
generation of "dt_line_out" and "dt_line_compl_out"; i.e. a disabled output
line "dt_line_out" has the value QUADRATURE_MODE[0] and a disabled output
line "dt_line_compl_out" has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down.
In QUAD mode, this field indicates the direction of the latest counter
change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for
dead time insertion. In all other modes, this counter is used for pre-scaling
the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the
counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared
to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count
for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0
Used to select triggers for specific counter events.</description>
            <addressOffset>0x20</addressOffset>
            <resetValue>0x00000010</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger
0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and
PWM_PR modes this trigger is used to switch the values if the compare
and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode,
this is the first phase (phi A). Default setting selects input trigger
1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode,
this is the index or revolution pulse. In this mode, it will update the
counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT
and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger
is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL
is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM
and PWM_DT modes, the blocking of the output signals can be  asynchronous
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long
as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE)
in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode,
this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1
Used to determine edge detection for specific counter triggers. Events
will only take effect on enabled counters.</description>
            <addressOffset>0x24</addressOffset>
            <resetValue>0x000003FF</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter
is initialized to "0". When counting down, the counter is initialized
with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running.
Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running.
Starting does NOT enable the counter. A start event will not initialize
the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2
Used to control counter "line_out", "dt_line_out" and "dt_line_compl_out"
output signals.</description>
            <addressOffset>0x28</addressOffset>
            <resetValue>0x0000003F</resetValue>
            <resetMask>0x0000003F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register)
on the "line_out" output signals.  Note that INVERT is especially useful
for center aligned pulse width modulation.
To generate a duty cycle of 0%, the counter CC register should be set
to "0". For a 100% duty cycle, the counter CC register should be set to
larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD)
on the "line_out" output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches "0")
on the "line_out" output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.
The register fields are not retained. This is to ensure that they come
up as '0' after coming out of DeepSleep system power mode. HW clears the
interrupt causes to '0', when the counter is disabled.</description>
            <addressOffset>0x30</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1'
to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected.
Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToClear</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.
When read, this register reflects the interrupt request register.</description>
            <addressOffset>0x34</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <modifiedWriteValues>oneToSet</modifiedWriteValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register
When read, this register reflects a bitwise AND between the interrupt
request and mask registers.</description>
            <addressOffset>0x3C</addressOffset>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBPD</name>
      <baseAddress>0x40080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USBPD0</name>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>USBPD1</name>
        <value>9</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000007</resetMask>
          <fields>
            <field>
              <name>TX_BYPASS_EN</name>
              <description>Setting this register will bypass 5b/4b, CRC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BYPASS_EN</name>
              <description>Setting this register will bypass 5b/4b, CRC.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_BYPASS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RX_SOP_ALLIGN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_RX_SOP_ALLGN</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_BYPASS</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IP_ENABLED</name>
              <description>IP enabled ('1') or not ('0').
"0" Resets the IP. The reset is an async reset.
Note that when the IP is disabled, all the interrupt sources are also
disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF7FE3</resetMask>
          <fields>
            <field>
              <name>RX_BUSY</name>
              <description>Receiver is currently receiving a packet</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_BUSY</name>
              <description>Transmitter is currently transmitting a packet or the crc timmer is running</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_DATA_VALID</name>
              <description>This status bit shows the CC_RX_VALID signal without noise_detected signal.
This is the output of the RX comparator and it is not qualified with noise
detection logic.
0: No Valid data on the CC line'
1: Valid Data detectd on the CC line</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SOP_TYPE_DETECTED</name>
              <description>Type of SOP detected for the packet stored in the RX SRAM:
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated.
If both are "0", then this register will be updated with the new packet
SOP value.
There is no clearing option.</description>
              <bitRange>[8:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SOP_RCVD</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEFAULT_SOP_RCVD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRIME_SOP_RCVD</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL_PRIME_SOP_RCVD</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBG_PRIME_SOP_RCVD</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBG_DBL_PRIME_SOP_RCVD</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD1_SOP_RCVD</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD2_SOP_RCVD</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GOODCRC_MSG_SOP_TYPE_DETECTED</name>
              <description>GoodCrc Message SOP type detected:
At the start of every packet, INTR.RCV_GOODCRC_MSG_COMPLETE status is
evaluated, if its reset, then this register will be updated with the new
packet SOP value.</description>
              <bitRange>[11:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SOP_GOODCRC_RCVD</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEFAULT_SOP_GOODCRC_RCVD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRIME_SOP_GOODCRC_RCVD</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL_PRIME_SOP_GOODCRC_RCVD</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBG_PRIME_SOP_GOODCRC_RCVD</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBG_DBL_PRIME_SOP_GOODCRC_RCVD</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD1_SOP_GOODCRC_RCVD</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD2_SOP_GOODCRC_RCVD</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RST_TYPE_DET</name>
              <description>RST Type detected:</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESERVED_RESET</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HARD_RESET_RCVD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CABLE_RESET_RCVD</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD1_RESET_RCVD</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD2_RESET_RCVD</name>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCONN1_STATUS</name>
              <description>VCONN1 status (wakeup interrupt from deepsleep)
1: VCONN1 > 2.7V
0: VCONN1 &lt; 2.7V</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCONN2_STATUS</name>
              <description>The status of either vconn2_changed or cmp_out  depending on the selection
defined in DEBUG_CC_0.VCONN2_CMP_OUT_SEL
VCONN2 status/cmp_out (wakeup interrupt from deepsleep)
If VCONN2_CMP_SEL = 0
       1: VCONN1 > 2.7V
       0: VCONN1 &lt; 2.7V
If VCONN2_CMP_SEL = 0
       1: cmp_out is 1
       0: cmp_out is 0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC1_STATUS</name>
              <description>CC1 status (wakeup interrupt from deepsleep)
1: CC1 attached
0: CC1 detached</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC2_STATUS</name>
              <description>CC2 status (wakeup interrupt from deepsleep)
1: CC2 attached
0: CC2 detached</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_LA_STATUS</name>
              <description>This register provides the status CC_LINE_ACTIVITY (wakeup interrupt from
deepsleep).</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_UP_STATUS</name>
              <description>This register provides the status of VCMP_UP (wakeup interrupt from deepsleep).
Not enabled unless CMP_EN bit is set.
Edge: Ra/Rd value changed
{VCMP_UP, VCMP_DN}:
00: Ra connected
01: Rd connected
11: Nothing connected (float)
               OR
Edge: Rp value changed
{VCMP_UP, VCMP_DN}:
00: Default Rp broadcast
01: 1.5A Rp broadcast
11: 3.0A Rp broadcast</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_DN_STATUS</name>
              <description>This register provides the status of VCMP_DN (wakeup interrupt from deepsleep).
Not enabled unless CMP_EN bit is set.
Edge: Ra/Rd value changed
               OR
Edge: Rp value changed</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOISE_DETECTED</name>
              <description>This status shows the noise detection on vcmp_up or vcmp_la or CC RX Line.
The source of noise from the comparator is selectable by  RX_CC: VCMP_UP_COMP_ENABLE,
VCMP_LA_COMP_ENABLE and RX_NOISE_CHECK_ENABLE.
The Noise detectition is defined by NOISE_EDGE_COUNT</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOISE_CC_DATA_VALID</name>
              <description>This status bit shows the CC_RX_VALID signal with the noise_detected signal
effect.
It is raw_cc_rx_valid &amp; !noise_detected.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_RX_DATA</name>
              <description>This status bit shows the RX Data comparator output from s8usbpd_cc_top.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_SOP_GOOD_CRC_EN_CTRL</name>
          <description>RX SOP Control for sending GoodCRC Message
Hardware will wait for programmable IDLE_COUNTER and then send Good Crc
Message.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000038</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>TX_SEND_DEFAULT_SOP_GOOD_CRC_EN</name>
              <description>Setting this bit will enable the TX block to automatically issue a GoodCRC
Message when the received
packet with Dafault SOP which has no CRC issue and the packet has been
written into SRAM successfully.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SEND_PRIME_SOP_GOOD_CRC_EN</name>
              <description>Setting this bit will enable the TX block to automatically issue a GoodCRC
Message when the received
packet with prime SOP which has no CRC issue and the packet has been written
into SRAM successfully.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SEND_DBL_PRIME_SOP_GOOD_CRC_EN</name>
              <description>Setting this bit will enable the TX block to automatically issue a GoodCRC
Message when the received
packet with dbl prime SOP which has no CRC issue and the packet has been
written into SRAM successfully.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_BAD_EOP</name>
              <description>Setting this bit will enable sending GoodCrcMsg for packet with Bad EOP.
This should be left to default for normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_BAD_KCHAR</name>
              <description>Setting this bit will enable sending GoodCrcMsg for packet with KCHAR
Error. This should be left to default for normal operation.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_NOISE_PKT</name>
              <description>Setting this bit will enable sending GoodCrcMsg for packet that has noise
during the whole packet. This should be left to default for normal operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DEFAULT_SOP_GOODCRC_CTRL</name>
          <description>RX Default SOP GoodCRC Control
            There are two purposes for this register:
            1. Transmit Path:
                When hardware is done transmitting a packet, it will start the RX_CRC_TIMER.
                The CRC timer should stop on following conditions:
    1. Good CRC Received: With Matching Message ID, Matching Header Sop
type.
                2. Hard Reset on Receive side
                3. Soft Reset on Receive Side:
                4. Any other message legal in the current firmware state:
    Condition 1, condition 2: These two conditions are automatically taken
care by hardware and CRC timer is stopped.
    Condition 3, condition 4: Firmware needs to take care of. Firmware
can program what legal messages it is expecting in a particular state
and hardware will stop its counter.
                                        E.G: If firmware wants the transmit
logic to stop its CRC counter and not retry the packet on reception of
these following messages:
                                        � Soft Reset Control Message:
 Message Type 1101
                                        � Get Source Cap Control Message:
Message Type 0111
                                        � Vendor Defined Data Message:
 Message Type 1111
                                        Then in that case firmware will
program RX_DEFAULT_SOP_GOODCRC_CTRL to: 8000_2080 (Bit 7th, bit 13th and
bit 31st)
                                        Hardware will stop the timers
on reception of these packets and will also automatically send GoodCRC
message to these messages
                                        if the proper auto bit is set
in RX_SOP_GOOD_CRC_EN_CTRL. Other messages received will be logged in
RX_Memory but Good CRC will not be returned or
                                        timer will not be stopped.
            2. Receive  Path:
    Based on one hot encoding of RX_DEFAULT_SOP_GOODCRC_CTRL mapped to
message type field in the incoming header,
    Good CRC will be returned automatically if the correct RX_SOP_GOOD_CRC_EN_CTRL
bit is set.</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_GOOD_CRC_PER_CTRL_MSG_TYP</name>
              <description>The Message type of a control message is a 4-bit field. Every bit of this
register mapps to the control
message types. CPU can used this register to select for which one of the
the message types of a control message should hardware send a GOODCRC
message.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_PER_DATA_MSG_TYP</name>
              <description>The Message type of a data message is a 4-bit field. Every bit of this
register mapps to the data
message types. CPU can used this register to select for which one of the
the message types of a data message should hardware send a GOODCRC message.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_PRIME_SOP_GOODCRC_CTRL</name>
          <description>RX Prime SOP GoodCRC Control</description>
          <addressOffset>0x10</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_GOOD_CRC_PER_CTRL_MSG_TYP</name>
              <description>The Message type of a control message is a 4-bit field. Every bit of this
register mapps to the control
message types. CPU can used this register to select for which one of the
the message types of a control message should hardware send a GOODCRC
message.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_PER_DATA_MSG_TYP</name>
              <description>The Message type of a data message is a 4-bit field. Every bit of this
register mapps to the data
message types. CPU can used this register to select for which one of the
the message types of a data message should hardware send a GOODCRC message.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DBL_PRIME_SOP_GOODCRC_CTRL</name>
          <description>RX DBL Prime SOP GoodCRC Control</description>
          <addressOffset>0x14</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_GOOD_CRC_PER_CTRL_MSG_TYP</name>
              <description>The Message type of a control message is a 4-bit field. Every bit of this
register mapps to the control
message types. CPU can used this register to select for which one of the
the message types of a control message should hardware send a GOODCRC
message.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEND_GOOD_CRC_PER_DATA_MSG_TYP</name>
              <description>The Message type of a data message is a 4-bit field. Every bit of this
register mapps to the data
message types. CPU can used this register to select for which one of the
the message types of a data message should hardware send a GOODCRC message.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_EXPECT_GOODCRC_MSG</name>
          <description>RX Excepted good CRC message to stop the CRC timers</description>
          <addressOffset>0x18</addressOffset>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>EXPECTED_HEADER</name>
              <description>The expected GoodCRC Messgae Header on the RX side. The expected message
ID is handled by Firmware.
The CRC timer will stop on:
1: On the reception of GoodCRC Messegae with good CRC32 where its header
matches with this register AND
2: The SOP of the GoodCRC Messgae matches with the EXPECTED_SOP.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXPECTED_SOP</name>
              <description>The expected SOP of GoodCRC Messgae on the RX side.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EXP_RESERVED</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_DEFAULT_SOP_RCVD</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_PRIME_SOP_RCVD</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_DBL_PRIME_SOP_RCVD</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_DBG_PRIME_SOP_RCVD</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_DBG_DBL_PRIME_SOP_RCVD</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_RSVD1_SOP_RCVD</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXP_RSVD2_SOP_RCVD</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISABLE_RX_CRC_TIMER</name>
              <description>FW should toggle this bit before commiting a new packet to be transferred
from TX_MEM.
0: Don�t disable the RX CRC count down
1: Disable the RX CRC count down.
   FW can disable the RX CRC timer whenever it detects the required condition.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_GOODCRC_MSG</name>
          <description>The 2-Byte Header of the received GoodCRC Message</description>
          <addressOffset>0x1C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>HEADER</name>
              <description>The INTR.RCV_GOODCRC_MSG_COMPLETE interrupt indicates the 2-Byte header
for GoodCRC message is received and stored in this registers.
GOODCRC_MSG_SOP_TYPE_DETECTED contains the SOP type for the GoodCRC MSG.
At the start of every packet, INTR.RCV_GOODCRC_MSG_COMPLETE status is
evaluated, if its reset, then only a new packet will be written else new
packet will be dropped.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CC</name>
          <description>The Receive C-Connect registers</description>
          <addressOffset>0x20</addressOffset>
          <resetValue>0x00000580</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CNT_MAX</name>
              <description>This value is internally multiplied by 4.
The 4X value when multiplied by the period of CLK_RX defines the maximum
clock period.
This value is used to cause the RX state machine to return to idle state
if no transitions are detected.
The default value of 0x80 is based on CLK_RX=24 Mhz
For 12 Mhz CLK_RX operations, set the value to 0x40</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UI_BOUNDARY_DELTA</name>
              <description>This value helps to define the 71% value of the UI. The Hardware automatically
calculates the 75% location.
The value of this register determines the number of RX_CLK between 71%
&amp; 75% location.
The default value of 0x5 is based on RX_CLK running at 24 Mhz.
For 12 Mhz CLK_RX operations, set the value to 0x3</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UI_TRANS_TO_ZERO</name>
              <description>This value should be set to half of shortest pulse width on RX line.
This will help detection of clock boundary after frequency calculation
is complete during preamble.</description>
              <bitRange>[19:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_VALID_NOISE_QUAL_ENABLE</name>
              <description>Setting this bit will qualify cc_rx_valid with noise detection logic.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_UP_COMP_ENABLE</name>
              <description>Enables noise check on vcmp_up comparator.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_LA_COMP_ENABLE</name>
              <description>Enables noise check on vcmp_la comparator.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOISE_CHECK_ENABLE</name>
              <description>Enables noise check on rx line.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOISE_EDGE_COUNT</name>
              <description>Defines number of noise edges that causes noise detection.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>THREE_TRANS_TRIG</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOUR_TRANS_TRIG</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIVE_TRANS_TRIG</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIX_TRANS_TRIG</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_ORDER_SET_CTRL</name>
          <description>Receive SOPs and RSTs order set control</description>
          <addressOffset>0x24</addressOffset>
          <resetValue>0x00006103</resetValue>
          <resetMask>0x0007FF0F</resetMask>
          <fields>
            <field>
              <name>SOP_CMP_OPT</name>
              <description>This register is used for SOP, SOP',SOP'", DEBUG SOP', DEBUG SOP" and
RX_RESERVED1/2_ORDER_SET(if configured for SOP) oder set detection. It
is recommended that CPU program this register to 1 ( 4 out of 4 option).
0: Compare 3 out of 4 order sets
1: Compare 4 out of 4 order sets</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_CMP_OPT</name>
              <description>This register is used for Cable RST, Hard RST and RX_RESERVED1/2_ORDER_SET(if
configure for RST) order set detection.
It is recommended that CPU program this register to 1 ( 4 out of 4 option).
0: Compare 3 out of 4 order sets
1: Compare 4 out of 4 order sets</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREAMBLE_SOP_EN</name>
              <description>This register is used to enable/disdable 16-bit preamble detection for
SOP detection.
0: SOP Detection:                              SOP logic detection
1: SOP detection: Preamble(16-bit)+ SOP logic detection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREAMBLE_RST_EN</name>
              <description>This register is used to enable/disdable 16-bit preamble detection for
RST detection.
0: RST Detection:                              RST logic detection
1: RST detection: Preamble(16-bit)+ RST logic detection</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOP_RST_EN</name>
              <description>Host Mode: F/W can enable SOP, SOP�, SOP� and Hard Reset Detection.
Device Mode: F/W should enable only SOP and Hard Reset Detection.
Cable Mode: Either SOP� or SOP� based on VCONN, Hard Reset and Cable Reset
should be enabled.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN_DEFAULT_SOP_DET</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_PRIME_SOP_DET</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_DBL_PRIME_SOP_DET</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_DEBUG_PRIME_SOP_DET</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_DEBUG_DBL_PRIME_DET</name>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_RX_CABLE_RESET_DET</name>
                  <value>32</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_RX_HARD_RESET_DET</name>
                  <value>64</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1_CFG</name>
                  <value>128</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_RESERVED1</name>
                  <value>256</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED2_CFG</name>
                  <value>512</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_RESERVED2</name>
                  <value>1024</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_RESERVED1_ORDER_SET</name>
          <description>Receive Reserved1 order set</description>
          <addressOffset>0x28</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_RESERVED1_OS</name>
              <description>Receive Reserved1 order set
This Register Can also be used for SOP' and SOP""
[15:0]   Can also be used for  Transmiting GoddCRC Message to SOP'
[31:16] Can also be used for  Transmiting GoddCRC Message to SOP"
This register constains the Transmit GoodCRC Message Header except the
MessageID which Is handled by Hardware.
[11:9] Message ID (This is handled by HardWare)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_RESERVED2_ORDER_SET</name>
          <description>Receive Reserved2 order set</description>
          <addressOffset>0x2C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>RX_RESERVED2_OS</name>
              <description>Receive Reserved2  order set</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA0</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x30</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA1</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x34</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA2</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x38</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA3</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x3C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA4</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x40</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA5</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x44</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA6</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x48</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MEM_DATA7</name>
          <description>RX SRAM Data
The memory for the RX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0050:   The Rx Header
0x0054:0x006C: The RX Data Object
 Any access to address space 0x0050 - 0x006C will map to SRAM address
x0-x15</description>
          <addressOffset>0x4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the receive SRAM. SOP type is stored in STATUS.SOP_TYPE_DETECTED
register.
The CPU should perform one read to register address 0x0030 to get the
Rx Header(16-bit). The upper 16-bit of the address 0x0030 should be ignored.
CPU should extract the 4-byte count from the Rx Header and perform the
proper number of read transactions.
STATUS.SOP_TYPE_DETECTED contains the SOP type for the packet in the RX
SRAM.
At the start of every packet, INTR.RCV_PACKET_COMPLETE and INTR.RCV_RST
status is evaluated, if its reset, then only a new packet will be written
else new packet will be dropped.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA0</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x50</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA1</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x54</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA2</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x58</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA3</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x5C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA4</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x60</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA5</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x64</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA6</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x68</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_MEM_DATA7</name>
          <description>TX SRAM Data
The memory for the TX USB power controller is a 32 byte SRAM. Address
map for this Memory is:
0x0030:   The Tx Header
0x0034:0x004C: The TX Data Object
 Any access to address space 0x0030 - 0x004C will map to SRAM address
x0-x15</description>
          <addressOffset>0x6C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Header/Data information in the transmitter SRAM. SOP/CRC/EOP will be appened
by HW.
The CPU is required to program the TX Header into lower 16-bit of register
address 0x0050.
The data read(Tx Header, 16-bit) from this address provides the number
of 4-bytes required to be transmitted. If the byte count is zero in the
Tx Header, then no more read will be issued to SRAM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>TX Control</description>
          <addressOffset>0x70</addressOffset>
          <resetValue>0x0F200041</resetValue>
          <resetMask>0x3F3FFFFF</resetMask>
          <fields>
            <field>
              <name>GOODCRC_MSG_BITS</name>
              <description>For SOP Only.
This register constains the Transmit GoodCRC Message Header except the
MessageID which Is handled by Hardware.
[11:9] Message ID (This is handled by HardWare)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TX_BIST_CM2</name>
              <description>Setting the EN_TX_BIST_CM2 to "1" will start the transmision of Bist Carrier
Mode 2 pattern.
FW must manually set TX_CTRL.TX_REG_EN to "1" before setting this register(EN_TX_BIST_CM2)
The TX_GO register is not required to be set for this mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_GO</name>
              <description>TX_GO causes a packet to be sent. FW can send GoodCrcMsg by storing it
in the TX SRAM and use TX_GO to send it.
Writing a 1 to this bit to cause the message stored in the SRAM Memory
to be sent.  Hardware clears this bit once the command is accepted and
processing has begun.
If TX_GO is set and there is a ongoing receive packet, the TX packet wont
be sent and the COLLISION_TYPE1
interrupt will be set. In this case, hardware clears the TX_GO.
Before setting this FW should check:
INTR0->RX_GOOD_PKT &amp;&amp; STATUS->DATA_VALID == 0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SEND_RST</name>
              <description>Send a Reset over the link. Write a 1 to this bit to cause the transmitter
to send a Hard Reset or Cable Reset(TX_HARD_CABLE_ORDER_SET register)
over the link. Hardware clears this bit once the command is accepted and
processing has begun.
If TX_SEND_RST is set and there is a ongoing receive packet, the Reset
Sequqnce wont be sent and the COLLISION_TYPE4 interrupt will be set. In
this case, hardware clears the TX_SEND_RST.
Before settting this FW should check:
INTR0->RX_GOOD_PKT &amp;&amp; STATUS->DATA_VALID == 0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_RETRY_ENABLE</name>
              <description>Enable transmit retry. Hardware clears this bit once the command is accepted
and processing has begun.
CPU should increment the retry counter in firmware once TX_PACKET_DONE
interrupt is detected by CPU.
CPU should set the Retry_Enable bit again if another retry is expected.
(CPU should have approximately 750 usec to set this bit).
The following operation is recommneded to FW:
   � FW maintains the retry counter
   � FW writes a packet in TX_Memory.
   � FW checks its retry counter and if its >0 , sets the retry enable
bit.
   � FW sets the TX_GO.
   � HW sends the packet and starts CRC_Timer if enabled.
   � On Expiry of CRC_timer, HW retries the packet if retry enable bit
was set and then HW auto clears that bit.
   � HW will start the CRC_timer again.
   � FW in parallel would have received the CRC_TIMER expiry interrupt�
FW will decrement its retry counter and if retry
     counter is still >0, then it will set the retry enable again
     ( F/W will have approx 1 msec to do this after getting previous CRC
timer expiry interrupt)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_REG_EN</name>
              <description>Enable the transmitter regulator</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_REG_CFG</name>
              <description>0: Hardware controlling of TX regulator Enable is disabled. CPU can fully
control the TX regulator enable by using TX_REG_EN.
1: Hardware controlling the TX regulator Enable is enabled. In this case,
CPU can only set the regulator enable to one by setting TX_REG_EN</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_REG_TIMER</name>
              <description>The time needed to enable the TX regulator before transmission.
The counter runs on CLK_TX_HALF(600Khz)</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_SOP_ORDER_SET</name>
          <description>Transmit SOP order set</description>
          <addressOffset>0x74</addressOffset>
          <resetValue>0x0008E318</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SOP_OS</name>
              <description>Transmit SOP order Set use in transmit except GoodCrcMsg</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_HARD_CABLE_ORDER_SET</name>
          <description>Transmit Hard/Cable reset order set</description>
          <addressOffset>0x78</addressOffset>
          <resetValue>0x000E7393</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RESET_OS</name>
              <description>Transmit Hard/Cable Reset order Set.
Default: Hard Reset Value 0xE7393
Cable Reset Value: 0xE0F8C</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_COUNTER</name>
          <description>The CRC timer counters/Bypass configuration
Counters used for the timmers needed by this IP</description>
          <addressOffset>0x7C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>CRC_COUNTER</name>
              <description>If TX_BYPASS_EN = 0:
         This counter will run on TX_CLK/2 (PD bit period) clock.
         This counter is used for CRCReceiveTimer(tReceive)/BISTReceiveErrorTimertBistReceive
         0: Counter is disabled. Hardware will NOT wait for the CRC_COUNTER
to expire.
         Other: Hardware will wait for the CRC_COUNTER to expire.
         Once the CRC_COUNTER reaches zero and no Valid CoodCRC message
is not received,
         The CRC_RX_TIMER_EXP interrupt gets set.
If TX_BYPASS_EN = 1:
        [10:0]: Total number of bits</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTER_PACKET_COUNTER</name>
          <description>The Inter Packet counters
Counters used for IDLE/IFG and  by this IP
All the timers/counters have a resolution of 1 UI (Unit Interval) of a
Bit. If transmit rate is 300Khz, then each count will tick for 3.33 usec.</description>
          <addressOffset>0x80</addressOffset>
          <resetValue>0x01004008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IDLE_CNT</name>
              <description>USED FOR TX->TX
This register is used by DUT to create gap between two back to back transmit
packets. For example: For a DFP application if DFP wants to send Hard
Reset after a valid packet, then this register could be used for complying
with Inter-Packet Gap of 25 usec specified by spec. In cable application,
after sending Good CRC handshake for request from DUT, this register could
be used to comply with 750usec requirement of cable response after sending
Good CRC pkt.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_COUNTER</name>
              <description>RX -> AUTO_GOODCRC_RESPONSE
This counter specifies how long the HW should wait after the end of RX
packet to send GoodCRC message. This can be used to comply with interpacket
gap of 25usec.
0: Counter is disabled. Hardware will issue goodcrc message if needed
after end of the RX Packet</description>
              <bitRange>[20:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IFG_COUNTER</name>
              <description>END OF ANY RX ON CC-LINE
On any RX Packet, this counter will start at end of RX Packet and will
reset on Start of RX Packet. This register can be again used to comply
with Interpacket Gap (25 usec + end of IDLE detection(12 usec)).
CPU after seeing no activity on the bus can immedeately set the TX_GO/TX_SEND_RST
bit and this register will make sure that we don't violate any interpacket
gap requirement.
0: Counter is disabled.</description>
              <bitRange>[31:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMER_TRIGGER</name>
          <description>The trigger enable registers
The tr_out[4:0] pins of this IP will be connected to the tr_in pin of
m0s8tcpwm_ver2 IP at the full chip. The mapping of the these signals is
SoC depended and it is defined
in SAS.</description>
          <addressOffset>0x84</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>EN_TRIGGER0</name>
              <description>1: The tr_out[0] pin of the IP will toggle on the transmission of the
last Bit Of EOP.
0: The toggling of the tr_out[0] pin of the IP is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TRIGGER1</name>
              <description>1: The tr_out[1] pin of the IP will toggle on the reception of EOP for
any message with Valid CRC (Includes
    Good Crc Message)
0: The toggling of the tr_out[1] pin of the IP is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TRIGGER2</name>
              <description>1: The tr_out[2] pin of the IP will toggle on the reception of EOP for
any message with Valid CRC (Excludes
    the message types specified in the RX_CTL register)
0: The toggling of the tr_out[2] pin of the IP is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TRIGGER3</name>
              <description>1: The tr_out[3] pin of the IP will toggle on the reception of EOP for
any message (Example: RX Hard Reset/ BIST)
0: The toggling of the tr_out[3] pin of the IP is disabled.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_TRIGGER4</name>
              <description>1: The tr_out[4] pin of the IP will toggle on the transmission of the
last Bit of EOP (Additional trigger for starting some different timer).
0: The toggling of the tr_out[4] pin of the IP is disabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SAR_CTRL</name>
          <description>ADC SAR Control Register
General Purpose voltgae measurement, Temperature Sceining</description>
          <addressOffset>0x88</addressOffset>
          <resetValue>0x00008000</resetValue>
          <resetMask>0x03FFFF01</resetMask>
          <fields>
            <field>
              <name>SAR_EN</name>
              <description>Setting this bit will enable the HW SAR logic.
Once the SAR_EN is one, Hardware will update the  SAR_OUT register after
8 cycles of clk_sar and clear this register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>MID_VAL</name>
              <description>ADC starting mid value</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAR_OUT</name>
              <description>ADC output resistance value
Stored 8-bit ADC value after the ID Pin voltage is sampled.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR_CMP_SEL</name>
              <description>This register selects which edge of cmp_out pin of the s8usbpd_adc_top
should be used to generate INT0.CMP_OUT_DET</description>
              <bitRange>[25:24]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_INT0_CMP_OUT_DET</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_RISE_EDGE</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_FALL_EDGE</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_BOTH_EDGE</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DDFT_MUX</name>
          <description>DDFT Selections</description>
          <addressOffset>0x8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ddft0_sel</name>
              <description>0: DDFT0 from previous m0s8usbpd instantiation if any
1:  vcmp_up
2:  vcmp_dn
3:  vcmp_la
4:  vconn1_det
5:  vconn2_det
6:  clk_tx
7:  cc_tx_data_valid
8:  cc_tx_data_eop
9:  cc_ctrl_tx_en
10: cc_rx_data
11: cc_core_rx_data
12: noise_cc_rx_valid</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ddft1_sel</name>
              <description>0: DDFT1 from previous m0s8usbpd instantiation if any
1: cc2_attach_det
2: cc1_attach_det
3: clk_rx
4: cc_tx_data
5: cc_core_tx_data
6: cc_rx_bit_en
7: raw_cc_rx_valid
8: rx_eop
9: rx_sop
10: noise_detected
11: noise_on_pkt
12:  vcmp_up
13:  vcmp_la</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_0_1_CFG</name>
          <description>Wakeup Interrupts edge and filter configuration and Intr0 configuration</description>
          <addressOffset>0x90</addressOffset>
          <resetValue>0x003FAAA8</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>INTR0_TX_PACKET_DONE_CFG</name>
              <description>Source of INTR0.TX_PACKET_DONE
0: TX EOP
1: CC Output Enable  de-assert</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR0_TX_CC_DATA_OEN_CFG</name>
              <description>Source of INTR0.TX_CC_DATA_OEN
0: CC Output Enable de-assert
1: TX EOP</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCONN1_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCONN2_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC1_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC2_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCMP_UP_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCMP_DN_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCMP_LA_CFG</name>
              <description>Edge detect2 positive/negative enable/disable</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_DIS_NEG_EDG_EN</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_DIS</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS_EDG_EN_NEG_EDG_EN</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VCONN1_FILT_EN</name>
              <description>Filtering the VCONN1_DET from s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCONN2_FILT_EN</name>
              <description>Filtering the VCONN2_DET from s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_CFG_FILT_EN</name>
              <description>Filtering the CC1_ATTACH from s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2_FILT_EN</name>
              <description>Filtering the CC2_ATTACH from s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_UP_FILT_EN</name>
              <description>Filtering the VCMP_UP from s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_DN_FILT_EN</name>
              <description>Filtering the VCMP_DNfrom s8usbpd.:
0: No Filtering
1: Enable 3 cycles of clk_lf filtering</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0</name>
          <description>INTR0 Cause</description>
          <addressOffset>0x94</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>RCV_GOOD_PACKET_COMPLETE</name>
              <description>Receive a Good non-GoodCRC-message Data Packet Complete. Indicates that
the Receive Packet has been received in its entirety.  The received packet
had no CRC and no KCHAR error.
If this interrupt is not cleared, then RX_OVER_RUN will be set on the
next new data and the new data won't be written into RX SRAM.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_BAD_PACKET_COMPLETE</name>
              <description>Receive a Bad non-GoodCRC-message Data Packet Complete. Indicates that
the Receive Packet has been received in its entirety.  The received packet
had CRC or KCHAR error.
If this interrupt is not cleared, then the new data will be written into
RX SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RX_SOP</name>
              <description>Receive a SOP. FW should read SOP_TYPE_DETECTED for the SOP type</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_GOODCRC_MSG_COMPLETE</name>
              <description>Receive GoodCRC-message Complete. Indicates that the GoodCRC-message is
stored in RX_GOODCRC_MSG register.
The received GoodCRC-message had no CRC error and no KCHAR error</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_EXPT_GOODCRC_MSG_COMPLETE</name>
              <description>Receive the expted GoodCRC-message based on the RX_EXPECT_GOODCRC_MSG
register. Indicates that the expected GoodCRC-message is stored in RX_GOODCRC_MSG
register.
The received expected GoodCRC-message had no CRC error and no KCHAR error
This interrupt gets evaluated on end of every packet (except hard reset)
and needs to be cleared.
For Correct usage of the interrupt:
This interrupt should be cleared on every packet if set.
RCV_GOOGCRC_MSG_COMPLETE should be cleared before new good crc response
comes else RX_GOODCRC_MSG will not get updated.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>EOP_ERROR</name>
              <description>Received Symbol wasn't a valid EOP K-Code.  It should be evaludated after
RCV_PACKET_COMPLETE.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RX_OVER_RUN</name>
              <description>New data was received when the RCV_PACKET_COMPLETE is not cleared by CPU.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TX_PACKET_DONE</name>
              <description>Transmitter done sending data packet.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TX_HARD_RST_DONE</name>
              <description>Transmitter done sending Hard Reset</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_RST</name>
              <description>Received a REST. FW should read RST_TYPE for the type of RST.
Firmware should process this interrupt according to the USB-PD spec.
Hardware does not process the Reset packets other than providing this
interrupt.
Hardware will stop processing any pending transmit packet until this interrupt
is cleared.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>SAR_DONE</name>
              <description>Marks Completion of SAR conversion at the end of 8 cycles of clk_sar when
SAR_EN is "1"</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TX_GOODCRC_MSG_DONE</name>
              <description>A GoodCRC message was transmitted.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC_VALID_DATA_DETECTED</name>
              <description>Valid Data detected on the CC line</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_DETECTED</name>
              <description>Valid Data got de-asserted on the CC line</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CRC_RX_TIMER_EXP</name>
              <description>CRCReceiveTimer has expired</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE1</name>
              <description>Transmit Collision Type1:
Collsion is detected Due to TX_GO(TX Data)/RX has occurred</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE2</name>
              <description>Transmit Collision Type2:
Collsion is detected  due to TX-RETRY/RX has occurred</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE3</name>
              <description>Transmit Collision Type3:
Collsion is detected due to TX-GoodCrc_MSG/RX has occurred</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE4</name>
              <description>Transmit Collision Type4:
Collsion is detected due to TX_SEND_RST/RX has occurred</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CMP_OUT_DET</name>
              <description>cmp_out pin of s8usbpd_adc_top changed based on the ADC_SAR_CTRL.INTR_CMP_SEL</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TX_SRAM_HALF_END</name>
              <description>Hardware has passed reading the data from Half or End of the TX SRAM Memory
Location</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RX_SRAM_HALF_END</name>
              <description>Hardware has passed writing the data to Half or End of the RX SRAM Memory
Location</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TX_CC_DATA_OEN</name>
              <description>TX Data Output Enable of TX-CC is de-asserted</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>KCHAR_ERROR</name>
              <description>Received Symbol wasn't a valid K-Code.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>NOISE_ON_PKT</name>
              <description>Detected noise during reception of Packet.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC_VALID_DATA_NOISE_DETECTED</name>
              <description>Valid Data detected on the CC line based on the noise_detected</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_NOISE_DETECTED</name>
              <description>Valid Data got de-asserted on the CC line based on the noise_detected</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1</name>
          <description>INTR1 Cause
The configurations for using the comparators:
DFP waiting for attach:
vcmp_up connected to CC1: HI = no connect, LO = attach
vcmp_dn connected to CC2: HI = no connect, LO = attach
DFP after attach:
vcmup_up at detach threshold: HI = detach, LO = attach
vcmp_dn at Rd/Ra threshold: HI = Rd connected, LO = Ra connected
vcmp_la at CC line activity threshold: HI = no activity, LO/Toggling =
activity
UFP (with VBUS present):
vcmup_up at Default/1.5A threshold: HI = Default, LO = 1.5A
vcmp_dn at 1.5A/3.0A threshold: HI = 1.5A, LO = 3.0A
vcmp_la at CC line activity threshold: HI = no activity, LO/Toggling =
activity
For detecting the difference between Rd/Ra, firmware will have to check
the �DFP after attach� state above to determine it.</description>
          <addressOffset>0x98</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>VCONN1_CHANGED</name>
              <description>VCONN1 changed (wakeup interrupt from deepsleep)
Check the STATUS.VCONN1_STATUS value</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VCONN2_CHANGED</name>
              <description>This interrupt can be either vconn2_changed or cmp_out Depending on the
selection defined in DEBUG_CC_0.VCONN2_CMP_OUT_SEL
VCONN2 changed/CMP_OUT (wakeup interrupt from deepsleep)
Check the STATUS.VCONN2_STATUS value</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC1_CHANGED</name>
              <description>CC1 changed (wakeup interrupt from deepsleep)
Check the STATUS.CC1_STATUS value</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CC2_CHANGED</name>
              <description>CC2 changed (wakeup interrupt from deepsleep)
Check the STATUS.CC2_STATUS value</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_LA_CHANGED</name>
              <description>VCMP_LA changed (wakeup interrupt from deepsleep)
Check the STATUS.VCMP_LA_STATUS value</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_UP_CHANGED</name>
              <description>VCMP_UP changed (wakeup interrupt from deepsleep)
Check the STATUS.VCMP_UP_STATUS value</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_DN_CHANGED</name>
              <description>VCMP_DN changed (wakeup interrupt from deepsleep)
Check the STATUS.VCMP_DN_STATUS value</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_SET</name>
          <description>INTR0 Set</description>
          <addressOffset>0x9C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>RCV_GOOD_PACKET_COMPLETE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_BAD_PACKET_COMPLETE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RX_SOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_GOODCRC_MSG_COMPLETE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_EXPT_GOODCRC_MSG_COMPLETE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>EOP_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RX_OVER_RUN</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>TX_PACKET_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>TX_HARD_RST_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RCV_RST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>SAR_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>TX_GOODCRC_MSG_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC_VALID_DATA_DETECTED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_DETECTED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CRC_RX_TIMER_EXP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE3</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>COLLISION_TYPE4</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CMP_OUT_DET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>TX_SRAM_HALF_END</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>RX_SRAM_HALF_END</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>TX_CC_DATA_OEN</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>KCHAR_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>NOISE_ON_PKT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC_VALID_DATA_NOISE_DETECTED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_NOISE_DETECTED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_SET</name>
          <description>INTR1 Set</description>
          <addressOffset>0xA0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>VCONN1_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>VCONN2_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC1_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CC2_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_LA_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_UP_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>VCMP_DN_CHANGED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_MASK</name>
          <description>INTR0 Mask</description>
          <addressOffset>0xA4</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>RCV_GOOD_PACKET_COMPLETE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCV_BAD_PACKET_COMPLETE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_SOP_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCV_GOODCRC_MSG_COMPLETE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCV_EXPT_GOODCRC_MSG_COMPLETE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOP_ERROR_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVER_RUN_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PACKET_DONE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_HARD_RST_DONE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RCV_RST_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAR_DONE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_GOODCRC_MSG_DONE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_VALID_DATA_DETECTED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_DETECTED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RX_TIMER_EXP_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLLISION_TYPE1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLLISION_TYPE2_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLLISION_TYPE3_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLLISION_TYPE4_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_OUT_DET_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SRAM_HALF_END_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_SRAM_HALF_END_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CC_DATA_OEN_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KCHAR_ERROR_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOISE_ON_PKT_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_VALID_DATA_NOISE_DETECTED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_NOISE_DETECTED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_MASK</name>
          <description>INTR1 Mask</description>
          <addressOffset>0xA8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>VCONN1_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCONN2_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC1_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC2_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_LA_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_UP_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCMP_DN_CHANGED_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_MASKED</name>
          <description>INTR0 Masked</description>
          <addressOffset>0xAC</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>RCV_GOOD_PACKET_COMPLETE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RCV_BAD_PACKET_COMPLETE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_SOP_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RCV_GOODCRC_MSG_COMPLETE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RCV_EXPT_GOODCRC_MSG_COMPLETE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EOP_ERROR_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_RUN_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PACKET_DONE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_HARD_RST_DONE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RCV_RST_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAR_DONE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_GOODCRC_MSG_DONE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_VALID_DATA_DETECTED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_DETECTED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_RX_TIMER_EXP_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COLLISION_TYPE1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COLLISION_TYPE2_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COLLISION_TYPE3_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COLLISION_TYPE4_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMP_OUT_DET_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_SRAM_HALF_END_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_SRAM_HALF_END_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CC_DATA_OEN_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>KCHAR_ERROR_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOISE_ON_PKT_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_VALID_DATA_NOISE_DETECTED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC_NO_VALID_DATA_NOISE_DETECTED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_MASKED</name>
          <description>INTR1 Masked</description>
          <addressOffset>0xB0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>VCONN1_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCONN2_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC1_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CC2_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_LA_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_UP_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VCMP_DN_CHANGED_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_CTRL</name>
          <description>Debug Control Register</description>
          <addressOffset>0xB4</addressOffset>
          <resetValue>0x037F0000</resetValue>
          <resetMask>0x0FFFFF0F</resetMask>
          <fields>
            <field>
              <name>RESET_RX</name>
              <description>This register are for debugging purposes.
0: Receive path is not at reset.
1: Reset the logic on the receive path except the Hard-IP.
    FW should check STATUS.RX_BUSY to make sure it is zero before setting
this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG_CAL_STATE</name>
              <description>Message Cal State</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MSGSM_IDLE</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_PRE_HDR</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_HDR</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_DATA</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_CRC</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_EOP</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSGSM_STAT</name>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET_TX</name>
              <description>This register are for debugging purposes
0: Transmit path is not at reset.
1: Reset the logic on the transmit path except the Hard-IP.
    FW should check STATUS.TX_BUSY to make sure it is zero before setting
this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG_STATE</name>
              <description>Transmit state machine</description>
              <bitRange>[12:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MSG_IDLE</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_CAL</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_SYN</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_HDR</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_DOBJ</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_CRC</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_EOP</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_RST</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSG_BIDLE</name>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_SRC_SEL_STATE</name>
              <description>TX SRC Select state machine</description>
              <bitRange>[15:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE_SEL</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL_SEL</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYN_SEL</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>KCHAR_SEL</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EOP_SEL</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RST_SEL</name>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_PREAMBLE_CNT</name>
              <description>Number of TX preambles+1 (bit transitions)</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOP_VALUE</name>
              <description>EOP value for Both RX and TX</description>
              <bitRange>[26:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUALIFY_RX_VALID_WITH_NOISE</name>
              <description>This bit is used to qualify the cc_rx_valid signal from cc module with
the noise_detected for collision logic.
0: Don't qualify cc_rx_valid with noise_detected
1: Qualify cc_rx_valid with noise_detected</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_CC_0</name>
          <description>C-Connector Debug control register 0</description>
          <addressOffset>0xB8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0FF1FFF</resetMask>
          <fields>
            <field>
              <name>TX_FIRST_BIT_LEVEL</name>
              <description>FW can only use this bit when the DEBUG_CC_0.TX_CC_DRIVE_SRC is set to
"1".
0: Disables the Transceiver to transmit data
1: Enables the Transceiver to transmit data</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP_BACK_NO_BMC</name>
              <description>When set enables TX to RX loopback before CC encoding/Decoding data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP_BACK_WITH_BMC</name>
              <description>Loobback after data encdoing. When set, the BMC encoded tx output will
loop back into cc_rx module.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_LOOP_BACK</name>
              <description>When set, enables rx module to decode cc_rx line all the time. (Including
during transmission).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_CLEAR</name>
              <description>When set to one, clears the BMC decoder RX state machines and counters.
It has to be set back to zero for normal operations.
RX_RESET is not required to be set</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLEAR</name>
              <description>When set to one, clears the TX state machines and counters. It has to
be set back to zero for normal operations.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CC_DRIVE_SRC</name>
              <description>This will selects either the m0s8usbpd_cc_tx or FW to control the TX_EN/TX_DATA
ports of the s8usbpd_cc_top Hard IP.
0: Hardware (m0s8usbpd_cc_tx) controls the TX_EN/TX_DATA ports of the
s8usbpd_cc_top Hard IP.
1: This option is for Testing/Char. FW controls the TX_EN/TX_DATA ports
of the s8usbpd_cc_top Hard IP.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CC_DATA</name>
              <description>FW can use this bit to dirve the CC data line when the TX_CC_DRIVE_SRC=1
and CC_DPSLP_REF_CTRL.TX_EN=1
When TX_CC_DRIVE_SRC is set to one:
- TX_EN port of the s8usbpd_cc_top is controlled by CC_DPSLP_REF_CTRL.TX_EN
- TX_DATA port of s8usbpd_cc_top Hard IP is controlled by TX_CC_DATA</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUG_SEL</name>
              <description>Selects the inputs to CC_DEBUG_OUT. Used for debug.
0. RX clk_cnt_q
1. RX cnt_max_q
2. RX cnt_min_q
3. Not defined yet.
4. RX {rx_state_q, cc_rx_data_del_q, one_detect_q}
5. RX {4'h0, cq_2, cq_3, cq_4, cq_5}
6. RX {2'h0, cc_rx_data, cc_rx_bit, cc_rx_valid, cc_rx_data_pin, cc_tx_data_pin,
cc_data_pin_oe}
7. Not defined yet.
8. Not defined yet.
9. TX {2'h0, tx_state_q, new_data_q}
10. TX {2'h0, cq_0, cq_3, cc_tx_data_lat_q, cc_tx_eof_lat_q, cc_tx_data_valid_lat_q,
cc_new_data_lat_q}
11.  TX {3'h0, cc_tx_data_pin, cc_data_pin_oe, cc_tx_data, cc_tx_eof,
cc_tx_data_valid}
12-15 not defined yet.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_CC_DATA_VALID_DIS</name>
              <description>0: RX_CC_DATA_VALID signal is not disabled.
1: RX_CC_DATA_VALID signal is disabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUG_OUT</name>
              <description>Debug output register. Its inputs are selected by CC_DEBUG_SEL</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IREF_SEL</name>
              <description>Selection bit for deepsleep vs. active current reference for Rp pull-up
termination
0 - Select deepsleep current reference
1 - Select active current reference</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCONN2_CMP_OUT_SEL</name>
              <description>Selection bit for source of wakeup between vconn2_changed and cmp_out.
0: vconn2_changed is the source
1: cmp_out  is the source</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CNT</name>
              <description>Used only for FPGA
0: Disabled
Other values: BMC encoder in m0s8usbpd_cc_tx module uses clk_tx and clk_tx_half
to transmit data at 300 KHz and clock transitions at 600 KHz. This scheme
provides a 50% duty cycle at all time. However receivers are required
to tolerate duty cycles of 35% to 65%. To help with debugging of the receiver
logic, the duty cycle of transmit data can become variable. This feature
is achieved by adding mmio_cc_tx_cnt&lt;7:0> register</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_CC_1</name>
          <description>C-Connector Debug control register 1</description>
          <addressOffset>0xBC</addressOffset>
          <resetValue>0x00501911</resetValue>
          <resetMask>0x00FF7F1F</resetMask>
          <fields>
            <field>
              <name>NUM_PREAMBLE_IGNORE</name>
              <description>Number of preamble bits to ignore at the beginning of the RX packet.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_PREAMBLE_AVG</name>
              <description>Number of preamble bits to be used in the RX for averaging CDR frequency.
Any time the value of these bits are changed, the values of NUM_TRANS_AVG
will need to be updated.</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FOUR_PREAM_AVG0</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOUR_PREAM_AVG1</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOUR_PREAM_AVG2</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EIGHT_PREAM_AVG</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIXTEEN_PREAM_AVG</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRTY_TWO_PREAM_AVG</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED6_PREAM_AVG</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED7_PREAM_AVG</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_TRANS_AVG</name>
              <description>Number of transitions required to complete averaging in the receiver.
This register will need to be updated any time values of NUM_PREAMBLE_AVG
is changed.
The values programmed into this register comes from the following table:
NUM_PREAMBLE_AVG = 000 : Use 0x19
NUM_PREAMBLE_AVG = 001 : Use 0x19
NUM_PREAMBLE_AVG = 010 : Use 0x7
NUM_PREAMBLE_AVG = 011 : Use 0xd
NUM_PREAMBLE_AVG = 100 : Use 0x19
NUM_PREAMBLE_AVG = 101 : Use 0x31</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DISABLE_AUTO_ADJ</name>
              <description>0: Automatic bit rate calculation by HW
1: Disables the RX-CC automatic bit rate detection and the RX_UI_PRERIOD
register is used for RX UI period.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UI_PERIOD</name>
              <description>When RX_DISABLE_AUTO_ADJ is set, this register value will define RX UI
period.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL</name>
          <description>S8USBPD DAC Control Register</description>
          <addressOffset>0xC0</addressOffset>
          <resetValue>0x80000200</resetValue>
          <resetMask>0x800683FF</resetMask>
          <fields>
            <field>
              <name>DAC_CNTRL</name>
              <description>Control bits for 8-bit DAC.
DAC_CNTRL register is used only if CPU wants to implement the SAR algorithm
in FW.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_MUXSEL</name>
              <description>ADC DFT Control:
0: Normal operation
1: DAC output voltage</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_ISO_N</name>
              <description>This is for when high voltage supply for a port is not present. This bit
should be set when the high voltage is present,
in order to ensure that the outputs are set to know values.
0: All outputs are isolated to a known value
1: Normal operation</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_OUT</name>
              <description>Comparator Output.  If voltage on ID pin is less than DAC voltage, then
cmp_out is HIGH.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VSEL</name>
              <description>Input Voltage select</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANA_IN1_AMUX_A</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ANA_IN2_AMUX_A</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAND_GAP</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BJT</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PD_LV</name>
              <description>ADC Power down control, active high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CC_CTRL_0</name>
          <description>S8USBPD C-connector Control Register 0</description>
          <addressOffset>0xC4</addressOffset>
          <resetValue>0xB0040000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_EN</name>
              <description>FW can only use this bit when the DEBUG_CC_0.TX_CC_DRIVE_SRC is set to
"1".
0: Disables the Transceiver to transmit data
1: Enables the Transceiver to transmit data</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EN</name>
              <description>Enables the Transceiver to receive data, Active High
This bit should be set after CC Line active interrupt (wakeup) in DeepSleep.
FW should set this bit at init and not change after across deep sleep
and wake.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_1V2</name>
              <description>Firmware detects cable attach and specifies whether CC1 or CC2 is connected
to the CC-line of the cable.
0 - CC1
1 - CC2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_EN</name>
              <description>CC line voltage Comparator enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_DN_CC1V2</name>
              <description>Connects cmp_dn comparator to CC1/CC2
0 - CC1
1 - CC2</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_DN_VSEL</name>
              <description>Selects the voltage threshold for cmp_dn comparator</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_0_2_VOL</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_4_VOL</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_55_VOL</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_655_VOL</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_8_VOL</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_235_VOL</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_575_VOL</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_2_6_VOL</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_UP_CC1V2</name>
              <description>Connects cmp_up comparator to CC1/CC2
0 - CC1
1 - CC2</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_UP_VSEL</name>
              <description>Selects the voltage threshold for cmp_up comparator</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_0_2_VOL</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_4_VOL</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_3_VOL</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_655_VOL</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_8_VOL</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_235_VOL</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_575_VOL</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_2_6_VOL</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_UP_OFFSET</name>
              <description>Selects the cmp_up comparator offset:</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_MINUS_50_MV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_100_MV</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_150_MV</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_200_MV</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_50_MV</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_100_MV</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_150_MV</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_200_MV</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_UP_OFFSET_EN</name>
              <description>Enables the offset generator for the cmp_up comparator
0 - no offset
1 - offset enabled, see CMP_UP_OFFSET register for value</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_LA_CC1V2</name>
              <description>Connects cmp_la comparator to CC1/CC2
0 - CC1
1 - CC2</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_LA_VSEL</name>
              <description>Selects the voltage threshold for cmp_la comparator</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_0_2_VOL</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_4_VOL</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_55_VOL</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_655_VOL</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_8_VOL</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_235_VOL</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_575_VOL</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_2_6_VOL</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_CC1_DB_DIS</name>
              <description>Disable Dead Battery Rd termination on CC1</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_CC2_DB_DIS</name>
              <description>Disable Dead Battery Rd termination on CC2</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_CC1_EN</name>
              <description>0: Disable CC1 Trimmed Rd Termination
1: Enable CC1 Trimmed Rd Termination</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_CC2_EN</name>
              <description>0: Disable CC2 Trimmed Rd Termination
1: Enable CC2 Trimmed Rd Termination</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RP_CC1_EN</name>
              <description>0: Disable CC1 Pull-up Termination (Rp)
1: Enable CC1 Pull-up Termination</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RP_CC2_EN</name>
              <description>0: Disable CC2 Pull-up Termination (Rp)
1: Enable CC2 Pull-up Termination</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RP_MODE</name>
              <description>Selects the Pull-up Termination current value
0, 2 - 80uA (Default current broadcast)
1 - 180uA (1.5A current broadcast)
3 - 330uA (3.0A current broadcast)</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PU0_80_UA</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PU1_1p5_A</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PU2_80_UA</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PU3_3A</name>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN_HYST</name>
              <description>Enables the hysteresis mode for the line activity comparator</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_MODE</name>
              <description>Selects the amount of line activity comparator hysteresis
0: 50mV hystersis
1: 100mV hysteresis"</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFP_EN</name>
              <description>Controls the reference voltage generator for DFP vs. UFP/Cable operation
0: UFP/Cable - voltage reference is 2.4V
1: DFP - voltage reference is 2.6V"
This register is a user configuration that must be set.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DISABLE</name>
              <description>Disables all active circuitry and DC paths
DS_ATTACH_DET_EN is still active</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CC_CTRL_1</name>
          <description>S8USBPD C-connector Control Register 1</description>
          <addressOffset>0xC8</addressOffset>
          <resetValue>0x00005000</resetValue>
          <resetMask>0x00007FDF</resetMask>
          <fields>
            <field>
              <name>CC_ADFT_EN</name>
              <description>Enables ADFT Mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CC_ADFT_CTRL</name>
              <description>Selects ADFT connection
See s8usbpd BROS for decoding details</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OFFSET_EN</name>
              <description>Enables the offset generator for the RX comparator
0 - no offset
1 - offset enabled, see RX_OFFSET register for value</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OFFSET</name>
              <description>Selects the RX comparator offset:</description>
              <bitRange>[9:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_MINUS_50_MV</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_100_MV</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_150_MV</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_MINUS_200_MV</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_50_MV</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_100_MV</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_150_MV</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_PLUS_200_MV</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DS_ATTACH_DET_EN</name>
              <description>Enables the deepsleep attach detect pull-up resistor
Set HI for a DFP waiting for attach</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VTX_SEL</name>
              <description>Transmit voltage select</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_0_93_V</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_03_V</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_125_V</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_225_V</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_33_V</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_43_V</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_53_V</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_63_V</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CC_ISO_N</name>
              <description>0: All outputs are isolated to a known value
1: Normal operation</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPSLP_REF_CTRL</name>
          <description>S8USBPD DeepSleep-Reference Control Register</description>
          <addressOffset>0xCC</addressOffset>
          <resetValue>0x00000009</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IGEN_EN</name>
              <description>Setting this bit will enable the deepsleep current reference outputs.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_ADFT_EN</name>
              <description>Setting this bit will enable the deepsleep reference generator ADFT mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_CTRL</name>
              <description>Controls the Deep Sleep reference ADFT mode
0: ganged 7 iref current sources
1: vrefdpslp voltage reference</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_DPSLP</name>
              <description>Block enable input
1 - All analog and DC paths cut off, outputs forced to known value
     This completely disables the CC Transceiver/Detect block.
0 - Normal functionality</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VCONN_CTRL</name>
          <description>S8USBPD VCONN control Register</description>
          <addressOffset>0xD0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>PUMP_EN</name>
              <description>Negative Charge Pump enable signal
0 - Pump disabled:
     Ra termination is present on both VCONN1 and VCONN2
1 - Pump enabled:
     Ra termination is cutoff on VCONN1 only if the EN_COMP1 is set
     Ra termination is cutoff on VCONN2 only if the EN_COMP2 is set</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_COMP1</name>
              <description>Enable VCONN1 comparator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_COMP2</name>
              <description>Enable VCONN2 comparator</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEAKER_CONFIG1</name>
              <description>VCONN1 leaker control</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEAKER_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_200_UA</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_1_UF</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_5_UF</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_UF</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_2_UF</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_5_UF</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_10_UF</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEAKER_CONFIG2</name>
              <description>VCONN2 leaker control</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEAKER_DIS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_200_UA</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_1_UF</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_0_5_UF</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_1_UF</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_2_UF</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_5_UF</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_10_UF</name>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PUMP_CTRL</name>
          <description>S8USBPD PUMP control Register</description>
          <addressOffset>0xD4</addressOffset>
          <resetValue>0x00000014</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>ADFT</name>
              <description>ADFT control</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_LV</name>
              <description>Bypasses the pumped output.  Pump output is connected to VDDD.
0: Charge pump output
1: Pump output shorted to VDDD</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>External clock select
0: Internal oscillator used for charge pump
1: External clock used for charge pump</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_PUMP</name>
              <description>Pump powerdown signal
0: Pump enabled
1: Pump disabled, all current paths cutoff</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_0</name>
          <description>S8USBPD Trim Register0 . Production trims stored in flash</description>
          <addressOffset>0xF00</addressOffset>
          <resetValue>0x00000040</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ZDRV_TRIM</name>
              <description>Trim bits for Driver termination impedance</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_TRIM</name>
              <description>Trim bits for TX Driver rise/fall slew rate</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_TRIM</name>
              <description>Trim bits for Rd pull-down resistor</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_1</name>
          <description>S8USBPD Trim Register1 . Production trims stored in flash</description>
          <addressOffset>0xF04</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RP_CC1_TRIM</name>
              <description>Trim bits for CC1 Pull-up current source
Firmware may need to read SFlash from location TBD and set this value
for each Rp value (RP_MODE)</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TC_I_TRIM_9P</name>
              <description>DeepSleep 2.4uA current reference temperature coefficient trim bit</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_2</name>
          <description>S8USBPD Trim Register2 . Production trims stored in flash</description>
          <addressOffset>0xF08</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RP_CC2_TRIM</name>
              <description>[5:0]: Trim bits for CC2 Pull-up current source
          Firmware may need to read SFlash from location TBD and set this
value for each Rp value (RP_MODE)
[7:6]:  Not Used. Spare trim bits</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TC_I_TRIM_4P</name>
              <description>DeepSleep 2.4uA current reference temperature coefficient trim bit</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_3</name>
          <description>S8USBPD C-connector Trim Register3. Production trims stored in flash</description>
          <addressOffset>0xF0C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>V0P55_TRIM</name>
              <description>Trim bits for 0.55V comparator reference</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>V0P655_TRIM</name>
              <description>Trim bits for 0.655V comparator reference</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_4</name>
          <description>S8USBPD C-connector Trim Register4. Production trims stored in flash</description>
          <addressOffset>0xF10</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>V0P74_TRIM</name>
              <description>Trim bits for 0.74V comparator reference</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>V0P8_TRIM</name>
              <description>Trim bits for 0.8V comparator reference</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_5</name>
          <description>S8USBPD C-connector Trim Register5. Production trims stored in flash</description>
          <addressOffset>0xF14</addressOffset>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>V1P125_TRIM</name>
              <description>Trim bits for 1.125V comparator reference</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>V1P235_TRIM</name>
              <description>Trim bits for 1.235V comparator reference</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_6</name>
          <description>S8USBPD C-connector Trim Register6. Production trims stored in flash</description>
          <addressOffset>0xF18</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>V1P575_TRIM</name>
              <description>Trim bits for 1.575V comparator reference</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_TRIM</name>
              <description>Beta multiplier reference trim bits.
Refer to GPM-541 for trim settings.</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>S8USBPD_TRIM_7</name>
          <description>S8USBPD C-connector Trim Register7. Production trims stored in flash</description>
          <addressOffset>0xF1C</addressOffset>
          <resetValue>0x000000F1</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>I_TRIM</name>
              <description>DeepSleep 2.4uA current reference trim bit.
Refer to s8usbpd BROS for bit settings.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value
in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register
Used to make system requests to SROM code.  System Requests transition
from User Mode to Privileged Mode.  See SAS for more details.  Firmware/ATE
should write CPUSS_SYSARG first and CPUSS_SYSREQ register next.</description>
          <addressOffset>0x4</addressOffset>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xF800FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected
to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector
fetches are always made to ROM. Note that this field does not affect DAP
accesses. Flash DfT routines may set this bit to '1' to enable uninhibited
read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0').
Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN
is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any
other write to this field sets is to '0'. This field is used as the AHB-Lite
hprot[1] signal to implement Cypress proprietary user/privileged modes.
These modes are used to enable/disable access to specific MMIO registers
and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field
to '1', on reset or when the SystemCall NMI vector is fetched from Boot
ROM. HW sets this field to '0', when the CPU is NOT executing from either
Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.
HW sets this field when the SYSREQ register is written to and SYSCALL_REQ
is '0' (the last time it is set is when SW sets SYSCALL_REQ from '0' to
'1').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0
field indicates the source of the write access. Setting this field to
'1' immediate results in a NMI. The SystemCall NMI interrupt handler sets
this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register
Used to make system requests to SROM code.  System Requests transition
from User Mode to Privileged Mode.  See SAS for more details.  Firmware/ATE
should write CPUSS_SYSARG first and CPUSS_SYSREQ register next.</description>
          <addressOffset>0x8</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends
on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection control register</description>
          <addressOffset>0xC</addressOffset>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>PROTECTION_MODE</name>
              <description>Current protection mode; this field is available as a global signal everywhere
in the system. Writes to this field are ignored when PROTECTION_LOCK is
'1':
0b1xxx: BOOT
0b01xx: KILL
0b001x: PROTECTED
0b0001: OPEN
0b0000: VIRGIN (also used for DEAD mode, but then FLASH_LOCK is also set)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_LOCK</name>
              <description>Setting this bit will force SPCIF.ADDRESS.AXA to be ignored, which prevents
SM Flash from being erased or overwritten. It is used to indicate the
DEAD protection mode. Writes to this field are ignored when PROTECTION_LOCK
is '1'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PROTECTION_LOCK</name>
              <description>Setting this field will block (ignore) any further writes to the PROTECTION_MODE
field in this register. Once '1', this field cannot be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_ROM</name>
          <description>ROM privilege register
ROM memory has a maximum capacity of 128 KByte. ROM is partitioned into
Boot ROM and System ROM. These two partitions are located back-to-back
in the system address space. The Boot ROM capacity is 4, 8, 16, or 32
KByte. The System ROM partition capacity equals the ROM capacity minus
the Boot ROM partition capacity.
User mode accesses to a privileged address result in an AHB-Lite bus error.
If the ROM memory capacity is not a power of two, the ROM memory region
has an unpopulated/unaccounted memory are (at the end of the ROM memory
region). A user mode access to an unpopulated, privileged area (as indicated
by the LIMIT field(s)) address results in an AHB-Lite bus error. A user
mode access to a unpopulated area, without any access violations, behaves
as follows: Reads return "0" and writes are ignore (RZWI).</description>
          <addressOffset>0x10</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>BROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of the Boot ROM partition
starts in increments of 256 Bytes.
"0":  Entire Boot ROM is Privileged.
"1":  First 256 Bytes are User accessable.
...
BROM_PROT_LIMIT >= "Boot ROM partition capacity": Entire Boot ROM partition
is user mode accessible.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM</name>
          <description>RAM privilege register
User mode accesses to a privileged address result in an AHB-Lite bus error.
If the RAM memory capacity is not a power of two, the RAM memory region
has an unpopulated/unaccounted memory are (at the end of the RAM memory
region). A user mode access to an unpopulated, privileged area (as indicated
by the LIMIT field(s)) address results in an AHB-Lite bus error. A user
mode access to a unpopulated area, without any access violations, behaves
as follows: Reads return "0" and writes are ignore (RZWI).</description>
          <addressOffset>0x14</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of SRAM starts in increments
of 256 Bytes.
"0":  Entire SRAM is Privileged.
"1":  First 256 Bytes are User accessable.
Any number larger than the size of the SRAM indicates that the entire
SRAM is user mode accessible.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_FLASH</name>
          <description>ROM privilege register
User mode accesses to a privileged address result in an+C48 AHB-Lite bus
error. If the regular flash memory capacity is not a power of two, the
regular flash memory region has an unpopulated/unaccounted memory are
(at the end of the regular flash memory region). A user mode access to
an unpopulated, privileged area (as indicated by the LIMIT field(s)) address
results in an AHB-Lite bus error. A user mode access to a unpopulated
area, without any access violations, behaves as follows: Reads return
"0" and writes are ignore (RZWI).</description>
          <addressOffset>0x18</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>FLASH_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of flash starts in increments
of 256 Bytes.
"0":  Entire flash is Privileged.
"1":  First 256 Bytes are User accessable.
Any number larger than the size of the flash indicates that the entire
flash is user mode accessible. Note that SuperVisory rows are always User
accessable.
If FLASH_PROT_LIMIT defines a non-empty privileged area, the boot ROM
will assume that a system call table exists at the beginning of the Flash
privileged area and use it for all SystemCalls made using SYSREQ.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>Wounding register
Wounding is based on the FLASH/SRAM memory address range. This range is
always the next power of 2 multiple of the FLASH/SRAM memory capacity.
E.g., a 48 KByte SRAM capacity has a 64 KByte memory address range. With
RAM_WOUND is "0", all 48 KByte SRAM capacity is accessible. With RAM_WOUND
is "1", the first 32 KByte SRAM capacity is accessible. With RAM_WOUND
is "2", the first 16 KByte SRAM capacity is accessible.</description>
          <addressOffset>0x1C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00770000</resetMask>
          <fields>
            <field>
              <name>RAM_WOUND</name>
              <description>Indicates the amount of accessible RAM 0 memory capacitty in this part.
The value in this field is effectively write-once (it is only possible
to set bits, not clear them). The remainder portion of SRAM is not accessible
and will return an AHB-Lite bus error.
"0": entire memory accessible
"1": first 1/2 of the memory accessible
"2": first 1/4 of the memory accessible
"3": first 1/8 of the memory accessible
"4": first 1/16 of the memory accessible
"5": first 1/32 of the memory accessible
"6": first 1/64 of the memory accessible
"7": first 1/128 of the memory accessible</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>FLASH_WOUND</name>
              <description>Indicates the amount of accessible flash in this part. The value in this
field is effectively write-once (it is only possible to set bits, not
clear them). The remainder portion of flash is not accessible and will
return an AHB-Lite bus error.
"0": entire memory accessible
"1": first 1/2 of the memory accessible
"2": first 1/4 of the memory accessible
"3": first 1/8 of the memory accessible
"4": first 1/16 of the memory accessible
"5": first 1/32 of the memory accessible
"6": first 1/64 of the memory accessible
"7": first 1/128 of the memory accessible (used for the DEAD protection
mode)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT</name>
          <description>DFT Select Register
Controls power switches of FLASH, ROM, SRAM macro(s) in CPUMEMSS. Note
that for StreetFighther this functionality is NOT available due to an
omission during IP development.</description>
          <addressOffset>0x2C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FLASH_PD</name>
              <description>Forcibly powers down Flash macro(s) when set and TEST_MODE is active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_PD</name>
              <description>Forcibly powers down system ROM macro(s) when set and TEST_MODE is active.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_PD</name>
              <description>Forcibly powers down system SRAM macro(s) periphery logic when set and
TEST_MODE is active. Memory array is connected to Vcchib and cannot be
powered down.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC_RAM_PD</name>
              <description>Forcibly powers down DW/DMA controller SRAM macro(s) (memory array and
pheriphery) when set and TEST_MODE is active.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000113</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
"0": 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash:
[0, 16] MHz system frequency)
"1": 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash:
[16, 32] MHz system frequency)
"2": 2 wait states (slow flash: [32, 48] MHz system frequency)
"3": undefined</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable seeting when FLASH_WS is "0" or when
predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use
this setting for older, slower ROM design and frequencies in the range
[0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies
in the range &lt;24, 48] MHz.
CPUSSv2 supports two types of ROM memory: an older, slower design (operating
at up to 24 MHz) and a newer, faster design (operating at up to 48 MHz).
The older design requires 1 wait state for frequencies above 24 MHz. The
newer design never requires wait states. All chips after Street Fighter
will use the newer design. As a result, all chips after Street Fighter
can always use 0 wait states.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_CMD</name>
          <description>Bist command register</description>
          <addressOffset>0x40</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>SRAM_GO</name>
              <description>1': Start SRAM BIST. Hardware set this field to '0' when BIST is completed.
SRAM BIST is functional up to 48 MHz. Note that this field is mutually
exclusive with the "SROM_GO" field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SROM_GO</name>
              <description>1': Start ROM BIST. Hardware set this field to '0' when BIST is completed.
SROM BIST is functional up to 24 MHz.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_DATA</name>
          <description>BIST data register</description>
          <addressOffset>0x44</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data that is written into a SRAM during a W0 substep (~BIST_DATA.DATA
is written into a SRAM during a W1 substep).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_CTL</name>
          <description>BIST control register</description>
          <addressOffset>0x4C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0010003F</resetMask>
          <fields>
            <field>
              <name>SRAMS_ENABLED</name>
              <description>Hot-one mask for the SRAMs for which the BIST is performed.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SRAM_CPUSS_MASK</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRAM_DMAC_MASK</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_0_MASK</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_1_MASK</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_2_MASK</name>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_3_MASK</name>
                  <value>32</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROW_FIRST</name>
              <description>Specifies how the SRAM BIST addresses are generated (should be set to
'0' for SROM BIST):
'0': Column address is incremented/decremented till it reaches its maximum/minimum
value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum
value and only then is the row address incremented/decremented.
'1': Row address is incremented/decremented till it reaches its maximum/minimum
value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum
value and only then is the column address incremented/decremented.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_STEP0_CTL</name>
          <description>BIST step 0 control register</description>
          <addressOffset>0x50</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>OPCODE</name>
              <description>Specifies what sequence of SRAM BIST steps (R0, R1, W0, W1) is performed
(not used for SROM BIST):
"0": W0. Write SRAM with BIST_DATA.DATA.
"1": W1. Write SRAM with ~BIST_DATA.DATA.
"2": R0. Read SRAM and compare output to BIST_DATA.DATA.
"3": R1. Read SRAM and compare output to ~BIST_DATA.DATA.
"4": W0, R0. Write SRAM with BIST_DATA.DATA, followed by read SRAM and
compare output to BIST_DATA.DATA (all to the same address).
"5": R0, W1.
"6": R1, W0.
"7": R0, W1, R1.
"8": R1, W0, R0.
"9": R0, W1, W0.
"10": R1, W0, W1.
"11": R0, W1, W0, W1.
"12": R1, W0, W1, W0.
"13": R0, W1, R1, W0.
"14": R1, W0, R0, W1.
"15": R0, W1, R1, W0, R0, W1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UP</name>
              <description>Specifies direction in which SRAM BIST steps through addresses (not used
for SROM BIST):
''0': BIST steps through the SRAM from the maximum row and column addresses
(as specified by a design time configurtion parameter when ADDR_START_ENABLED
is '0' and as specified by BIST_ADDR_START when ADDR_START_ENABLED is
'1')  to the minimum row and column addresses.
'1': BIST steps through the SRAM from the minimum row and column addresses
("0" when ADDR_START_ENABLED is '0' and as specified by BIST_ADDR_START
when ADDR_START_ENABLED is '1') to the maximum row and column addresses.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_STATUS</name>
          <description>BIST status register</description>
          <addressOffset>0x80</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01000000</resetMask>
          <fields>
            <field>
              <name>SUB_STEP</name>
              <description>BIST substep (either R0, R1, W0, or W1).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STEP</name>
              <description>BIST step (step i uses BIST_STEPi_CTL).</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM</name>
              <description>SRAM identifier.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SRAM_CPUSS</name>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRAM_DMAC</name>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_0</name>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_1</name>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_2</name>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_3</name>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_4</name>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_5</name>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_6</name>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_7</name>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_8</name>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_9</name>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_10</name>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_11</name>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_12</name>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT_SRAM_13</name>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FAIL</name>
              <description>0': BIST passed.
'1': BIST failed (SRAM match error or ROM MISR check error). BIST error
information is found in SRAM, STEP, SUB_STEP fields and BIST_DATA_ACT,
BIST_DATA_EXP and BIST_ADDR registers.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_DATA_ACT</name>
          <description>BIST data expected register</description>
          <addressOffset>0x84</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>For SRAM BIST, this field is the SRAM output data that caused a BIST failure.
For ROM BIST, this field is the calculated Mulitple Input Shift Register
(MISR).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_DATA_EXP</name>
          <description>BIST data actual register</description>
          <addressOffset>0x88</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>For SRAM BIST. This field is the expected data from SRAM. This value is
BIST_DATA.DATA for a R0 substep and ~BIST_DATA.DATA for a R1 substep.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_ADDR</name>
          <description>BIST address register</description>
          <addressOffset>0x8C</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>COL_ADDR</name>
              <description>Current column address.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ROW_ADDR</name>
              <description>Current row address.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_MISR</name>
          <description>BIST SROM Multiple Input Shift Register (MISR)</description>
          <addressOffset>0x90</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Current value of ROM Multiple Input Shift Register (MISR).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTM_CTL</name>
          <description>Parallel Test Mode Control Register
This register determines the test interface (SWD or PTM) that connects
the ATE to the device.</description>
          <addressOffset>0xC0</addressOffset>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>PTM_EN</name>
              <description>0': SWD mode.
'1': PTM mode.
This bit is typically set to '1' through the SWD interface to switch to
the PTM interface and it is typically set to '0' through the PTM interface
to switch to the SWD interface. This bit replaces the m0s8tst IP's CTRL.PTM_MODE_EN
MMIO register field, which is rendered ineffective when using CPUSSv2.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>